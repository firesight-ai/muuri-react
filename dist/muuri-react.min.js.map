{
  "version": 3,
  "sources": ["../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/lib/ReactPropTypesSecret.js", "../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/factoryWithThrowingShims.js", "../node_modules/.pnpm/prop-types@15.8.1/node_modules/prop-types/index.js", "../src/index.ts", "../src/prototype.ts", "../src/utils/decorators/decorationKey.ts", "../src/utils/decorators/isDecorated.ts", "../src/utils/decorators/addDecoration.ts", "../src/utils/decorators/getDecoration.ts", "../src/utils/decorators/removeDecorations.ts", "../src/components/gridComponent.tsx", "../src/components/itemComponent.tsx", "../src/contexts/gridContext.ts", "../src/contexts/itemContext.ts", "../src/controllers/eventController.ts", "../src/controllers/itemAddController.ts", "../src/invariant.ts", "../src/controllers/itemRefController.ts", "../src/controllers/itemRemoveController.ts", "../src/controllers/layoutController.ts", "../src/controllers/fiberController.ts", "../src/controllers/childrenController.ts", "../src/utils/fillers/fillGrid.ts", "../src/utils/fillers/fillGridElement.ts", "../src/utils/fillers/fillItem.ts", "../src/utils/fillers/fillItemElement.ts", "../src/utils/hooks/useFunction.ts", "../src/utils/hooks/useInstantEffect.ts", "../src/utils/hooks/useReference.ts", "../src/utils/hooks/useMemoized.ts", "../src/utils/hooks/useRerender.ts", "../src/utils/grid/addItems.ts", "../src/utils/grid/filterItems.ts", "../src/utils/grid/getGridClass.ts", "../src/utils/grid/getItemClasses.ts", "../src/utils/grid/hideItems.ts", "../src/utils/grid/removeItems.ts", "../src/utils/grid/showItems.ts", "../src/utils/grid/sortItems.ts", "../src/components/muuriComponent.tsx", "../src/muuri-map.ts", "../src/utils/muuri/getInstance.ts", "../src/utils/muuri/handleRef.ts", "../src/utils/muuri/setDragAutoScroll.ts", "../src/utils/muuri/setDragContainer.ts", "../src/utils/muuri/setDragSort.ts", "../src/utils/muuri/setDragStartPredicate.ts", "../src/hooks/index.ts", "../src/hooks/useData.ts", "../src/hooks/useDrag.ts", "../src/hooks/useDraggable.ts", "../src/hooks/useGrid.ts", "../src/hooks/useRefresh.ts", "../src/hooks/useShow.ts", "../src/hooks/useVisibility.ts", "../src/tools/getResponsiveStyle.ts", "../src/tools/getStaticStyle.ts", "../src/tools/withHooks.tsx"],
  "sourcesContent": ["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n", "/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n", "/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n", "import Muuri from 'muuri';\r\nimport './prototype';\r\nimport './declare-muuri';\r\n\r\n// Muuri-exports.\r\nexport const AutoScroller = Muuri.AutoScroller;\r\nexport const ItemDrag = Muuri.ItemDrag;\r\n\r\n// Muuri-react exports.\r\nexport * from './components';\r\nexport * from './hooks';\r\nexport * from './contexts';\r\nexport * from './controllers';\r\nexport * from './tools';\r\nexport * from './muuri-map';\r\n", "import Muuri from 'muuri';\r\nimport {getDecoration} from './utils/decorators';\r\n\r\n/**\r\n * Muuri id getter.\r\n *\r\n * @returns - The id of the instance.\r\n */\r\nMuuri.prototype.getId = function getId() {\r\n  return getDecoration(this).id;\r\n};\r\n/**\r\n * Muuri group ids getter.\r\n *\r\n * @returns - The group ids of the instance.\r\n */\r\nMuuri.prototype.getGroupIds = function getGroupIds() {\r\n  return getDecoration(this).groupIds;\r\n};\r\n/**\r\n * Muuri size element getter.\r\n *\r\n * @returns - The group ids of the instance.\r\n */\r\nMuuri.prototype.getSizerElement = function getSizerElement() {\r\n  return getDecoration(this).sizerElement;\r\n};\r\n\r\n/**\r\n * Item key getter.\r\n *\r\n * @returns - The item component key.\r\n */\r\nMuuri.Item.prototype.getKey = function getKey() {\r\n  return getDecoration(this).key;\r\n};\r\n/**\r\n * Item props getter.\r\n *\r\n * @returns - The item component props.\r\n */\r\nMuuri.Item.prototype.getProps = function getProps() {\r\n  return getDecoration(this).props;\r\n};\r\n/**\r\n * Item data getter.\r\n *\r\n * @returns - The item component data.\r\n */\r\nMuuri.Item.prototype.getData = function getData() {\r\n  return getDecoration(this).data;\r\n};\r\n/**\r\n * Item data setter.\r\n *\r\n * @param data - The data.\r\n */\r\nMuuri.Item.prototype.setData = function setData(data: object) {\r\n  getDecoration(this).data = data;\r\n};\r\n", "export default '_component' as const;\r\n", "import key from './decorationKey';\r\nimport type {MaybeDecorated} from '../../interfaces';\r\n\r\n/**\r\n * Return if the instance is decorated.\r\n *\r\n * @param instance - The instance.\r\n * @returns - If the instance is decorated.\r\n */\r\nexport function isDecorated(instance: MaybeDecorated): boolean {\r\n  return !!instance[key];\r\n}\r\n", "import key from './decorationKey';\r\nimport {isDecorated} from './isDecorated';\r\nimport type {MaybeDecorated} from '../../interfaces';\r\n\r\n/**\r\n * Add a decoration to the instance.\r\n *\r\n * @param instance - The instance to decorate.\r\n * @param decoration - The decoration.\r\n */\r\nexport function addDecoration<T extends MaybeDecorated>(\r\n  instance: T,\r\n  decoration: Partial<T[typeof key]>\r\n): void {\r\n  if (isDecorated(instance)) {\r\n    // @ts-ignore\r\n    Object.assign(instance[key], decoration);\r\n  } else {\r\n    instance[key] = {...decoration};\r\n  }\r\n}\r\n", "import key from './decorationKey';\r\nimport type {Decorated} from '../../interfaces';\r\n\r\n/**\r\n * Add a decoration to the instance.\r\n *\r\n * @param instance - The instance to decorate.\r\n * @param decoration - The decoration.\r\n */\r\nexport function getDecoration<T extends Decorated>(instance: T): T[typeof key] {\r\n  return instance[key];\r\n}\r\n", "import type {MaybeDecorated} from '../../interfaces';\r\n\r\n/**\r\n * Remove the decoration from the instance.\r\n *\r\n * @param decorated - The instance.\r\n */\r\nexport function removeDecorations(decorated: MaybeDecorated): void {\r\n  decorated._component = null;\r\n}\r\n", "/* React */\r\nimport React, {createRef, RefObject, useEffect} from 'react';\r\nimport PropTypes from 'prop-types';\r\n/* Components */\r\nimport {ItemComponent} from './itemComponent';\r\n/* Context */\r\nimport {GridProvider} from '../contexts';\r\n/* Controllers */\r\nimport {\r\n  ChildrenController,\r\n  FiberController,\r\n  ItemAddController,\r\n  ItemRemoveController,\r\n  LayoutController,\r\n} from '../controllers';\r\n/* Utils */\r\nimport {invariant} from '../invariant';\r\nimport {fillGridElement, fillGrid} from '../utils/fillers';\r\nimport {useReference, useMemoized} from '../utils/hooks';\r\nimport {addDecoration, getDecoration, isDecorated} from '../utils/decorators';\r\nimport {\r\n  addItems,\r\n  filterItems,\r\n  getGridClass,\r\n  getItemClasses,\r\n  hideItems,\r\n  removeItems,\r\n  showItems,\r\n  sortItems,\r\n} from '../utils/grid';\r\n/* Interfaces */\r\nimport type {GridComponentProps, DecoratedItem} from '../interfaces';\r\n\r\n// Grid component.\r\nexport function GridComponent({\r\n  children,\r\n  gridProps,\r\n  grid,\r\n  filter,\r\n  sort,\r\n  sortOptions,\r\n  addOptions,\r\n  propsToData,\r\n  onSend,\r\n  onDragStart,\r\n  onDragEnd,\r\n  onFilter,\r\n  onSort,\r\n  onMount,\r\n  onUnmount,\r\n  forceSync,\r\n  dragFixed,\r\n  dragEnabled,\r\n  instantLayout,\r\n}: GridComponentProps) {\r\n  /* ------------------ */\r\n  /* ----- STORES ----- */\r\n  /* ------------------ */\r\n\r\n  // Store references of objects\r\n  // generated in previous renders.\r\n  const store = useMemoized<{\r\n    // The grid ref.\r\n    gridRef: RefObject<HTMLDivElement>;\r\n    // The grid className.\r\n    gridClass: string;\r\n    // The items classNames.\r\n    itemClasses: string[];\r\n    // Controller that manages the children.\r\n    childrenController: ChildrenController;\r\n    // Controller that manages the fibers.\r\n    fiberController: FiberController;\r\n    // Controller that manages the items to add.\r\n    itemAddController: ItemAddController;\r\n    // Controller that manages the items to remove.\r\n    itemRemoveController: ItemRemoveController;\r\n    // Controller that manages the items layout.\r\n    layoutController: LayoutController;\r\n    // Keep a reference of the onUnmount function.\r\n    onUnmount?: GridComponentProps['onUnmount'];\r\n    // Keep a reference of the onDragStart function.\r\n    onDragStart?: GridComponentProps['onDragStart'];\r\n    // Keep a reference of the onDragEnd function.\r\n    onDragEnd?: GridComponentProps['onDragEnd'];\r\n    // Keep a reference of the onFilter function.\r\n    onFilter?: GridComponentProps['onFilter'];\r\n    // Keep a reference of the onSort function.\r\n    onSort?: GridComponentProps['onSort'];\r\n    // Keep a reference of the onSend function.\r\n    onSend?: GridComponentProps['onSend'];\r\n  }>(() => ({\r\n    // Grid and items data.\r\n    gridRef: /*      */ createRef(),\r\n    gridClass: /*    */ getGridClass(grid),\r\n    itemClasses: /*  */ getItemClasses(grid),\r\n    // Controllers.\r\n    childrenController: /*    */ new ChildrenController(),\r\n    fiberController: /*       */ new FiberController(),\r\n    itemAddController: /*     */ new ItemAddController(),\r\n    itemRemoveController: /*  */ new ItemRemoveController(),\r\n    layoutController: /*      */ new LayoutController(),\r\n    // Events.\r\n    onUnmount,\r\n    onDragStart,\r\n    onDragEnd,\r\n    onFilter,\r\n    onSort,\r\n    onSend,\r\n  }));\r\n\r\n  // Store references of objects\r\n  // that are used inside useEffect.\r\n  // The references are flushed on each new render.\r\n  const vars: {\r\n    /** The positions of the new items. */\r\n    indicesToAdd: number[];\r\n    /** The DOM elements of the new items. */\r\n    addedDOMItems: HTMLElement[];\r\n    /** The items instances to remove. */\r\n    itemsToRemove: DecoratedItem[];\r\n    /** The items instances to refresh. */\r\n    itemsToRefresh: DecoratedItem[];\r\n    /** The items instances to show. */\r\n    itemsToShow: DecoratedItem[];\r\n    /** The items instances to hide. */\r\n    itemsToHide: DecoratedItem[];\r\n    /** If an item has been added. */\r\n    hasAdded: boolean;\r\n    /** If an item has been removed. */\r\n    hasRemoved: boolean;\r\n    /** If the grid has been filtered. */\r\n    hasFiltered: boolean;\r\n    /** If the grid has been sorted. */\r\n    hasSorted: boolean;\r\n    /** If an item has been refreshed. */\r\n    hasRefreshed: boolean;\r\n    /** If an item has been shown. */\r\n    hasShown: boolean;\r\n    /** If an item has been hiiden. */\r\n    hasHidden: boolean;\r\n  } = {\r\n    // Items data.\r\n    indicesToAdd: /*   */ [],\r\n    addedDOMItems: /*  */ [],\r\n    itemsToRemove: /*  */ [],\r\n    itemsToRefresh: /* */ [],\r\n    itemsToShow: /*    */ [],\r\n    itemsToHide: /*    */ [],\r\n    // Items flags.\r\n    hasAdded: /*      */ false,\r\n    hasRemoved: /*    */ false,\r\n    hasFiltered: /*   */ false,\r\n    hasSorted: /*     */ false,\r\n    hasRefreshed: /*  */ false,\r\n    hasShown: /*      */ false,\r\n    hasHidden: /*     */ false,\r\n  };\r\n\r\n  /* ----------------- */\r\n  /* ----- MOUNT ----- */\r\n  /* ----------------- */\r\n\r\n  // Initialize the grid on mount.\r\n  useEffect(() => {\r\n    /* ------------------ */\r\n    /* ----- EVENTS ----- */\r\n    /* ------------------ */\r\n\r\n    // Add all the event handlers.\r\n    grid\r\n      // \"Send\" and \"receive\" events.\r\n      .on('beforeSend', ({item, fromGrid, fromIndex}) => {\r\n        if (!getDecoration(item).sentPayload) {\r\n          // Generate the sentPayload.\r\n          const sentPayload = {\r\n            fromChildrenController: store.childrenController,\r\n            fromFiberController: store.fiberController,\r\n            fromGrid,\r\n            fromIndex,\r\n          };\r\n\r\n          // Add the decoration.\r\n          addDecoration(item, {sentPayload});\r\n        }\r\n      })\r\n      .on('receive', ({item, toGrid, toIndex}) => {\r\n        // Controllers.\r\n        const toChildrenController = store.childrenController;\r\n        const toFiberController = store.fiberController;\r\n\r\n        // If the method is activated by user interaction (the item is being dragged)\r\n        // the synchronization will be performed during the \"dragEnd\" event.\r\n        // If the method is called via Muuri's instance (the item is not being dragged)\r\n        // the synchronization takes place here, but the onSend callback is not fired.\r\n        if (item.isDragging()) {\r\n          // Generate the receivedPayload.\r\n          const receivedPayload = {\r\n            toChildrenController,\r\n            toFiberController,\r\n            toGrid,\r\n            toIndex,\r\n          };\r\n\r\n          // Add the decoration.\r\n          addDecoration(item, {receivedPayload});\r\n        } else {\r\n          // Payloads data.\r\n          const sentPayload = getDecoration(item).sentPayload;\r\n          // The payload must have been created in the send method.\r\n          invariant(sentPayload !== null && typeof sentPayload === 'object');\r\n          // Controllers.\r\n          const {fromChildrenController, fromFiberController} = sentPayload;\r\n\r\n          // Remove the payload.\r\n          addDecoration(item, {sentPayload: null});\r\n\r\n          // Remove the item instances from the old GridComponent.\r\n          const itemFiber = fromFiberController.remove(item.getKey());\r\n          const itemComponent = fromChildrenController.remove(itemFiber.index);\r\n\r\n          // Add the item instances to the new GridComponent.\r\n          toFiberController.append(itemFiber);\r\n          toChildrenController.append(itemComponent);\r\n        }\r\n\r\n        // Emit the \"send\" event.\r\n        getDecoration(item).eventController.emitEvent('send', grid);\r\n      })\r\n\r\n      // Drag events.\r\n      .on('dragInit', (item, event) => {\r\n        // The childrenController must change the positions of\r\n        // the newly added components if any items are being\r\n        // dragged to add the safely.\r\n        store.childrenController.incrementDragCounter();\r\n        // Emit the \"drag\" event.\r\n        // This event is used instead of \"dragStart\" to allow the\r\n        // reRender of the component when the item is not inside\r\n        // the dragContainer, this makes it possible to change\r\n        // the style of the element safely (e.g. using relative dimensions).\r\n        getDecoration(item).eventController.emitEvent('drag', true);\r\n        // \"onDragStart\" Callback.\r\n        if (store.onDragStart) store.onDragStart(item, event);\r\n      })\r\n      .on('dragEnd', (item) => {\r\n        // Payloads.\r\n        const sentPayload = getDecoration(item).sentPayload;\r\n        const receivedPayload = getDecoration(item).receivedPayload;\r\n\r\n        // If an item was sent during the drag the\r\n        // GridComponents are synchronized.\r\n        if (sentPayload && receivedPayload) {\r\n          // SentPayload data.\r\n          const {\r\n            fromChildrenController,\r\n            fromFiberController,\r\n            fromGrid,\r\n            fromIndex,\r\n          } = sentPayload;\r\n\r\n          // ReceivedPayload data.\r\n          const {\r\n            toChildrenController,\r\n            toFiberController,\r\n            toGrid,\r\n            toIndex,\r\n          } = receivedPayload;\r\n\r\n          // Reset the payloads.\r\n          addDecoration(item, {sentPayload: null, receivedPayload: null});\r\n\r\n          // Check if the item has been sended.\r\n          if (fromGrid !== toGrid) {\r\n            // \"onSend\" will be called with the receive event.\r\n            invariant(\r\n              typeof store.onSend === 'function',\r\n              'An item cannot be sent to another MuuriComponent if the ' +\r\n                \"'onSend' property has not been passed to the MuuriComponent.\"\r\n            );\r\n\r\n            // Remove the item instances from the old GridComponent.\r\n            const itemFiber = fromFiberController.remove(item.getKey());\r\n            const itemComponent = fromChildrenController.remove(\r\n              itemFiber.index\r\n            );\r\n\r\n            // Add the item instances to the new GridComponent.\r\n            toFiberController.append(itemFiber);\r\n            toChildrenController.append(itemComponent);\r\n\r\n            // \"onSend\" callback.\r\n            // DragEnd is called in the grid where\r\n            // the drag start, so onSend.\r\n            store.onSend({\r\n              // The key the user has set.\r\n              key: getDecoration(item).key,\r\n              // From.\r\n              fromGrid,\r\n              fromIndex,\r\n              fromId: getDecoration(fromGrid).id,\r\n              fromGroupIds: getDecoration(fromGrid).groupIds,\r\n              // To.\r\n              toGrid,\r\n              toIndex,\r\n              toId: getDecoration(toGrid).id,\r\n              toGroupIds: getDecoration(toGrid).groupIds,\r\n            });\r\n          }\r\n        }\r\n      })\r\n      .on('dragReleaseEnd', (item) => {\r\n        // The childrenController must change the positions of\r\n        // the newly added components if any items are being\r\n        // dragged to add the safely.\r\n        store.childrenController.decrementDragCounter();\r\n        // Emit the event.\r\n        // This event is used instead of \"dragEnd\" to allow the\r\n        // reRender of the component when the item is not inside\r\n        // the dragContainer, this makes it possible to change\r\n        // the style of the element safely (e.g. using relative dimensions).\r\n        getDecoration(item).eventController.emitEvent('drag', false);\r\n        // Call the event.\r\n        if (store.onDragEnd) store.onDragEnd(item);\r\n      })\r\n\r\n      // Show and hide events.\r\n      .on('showStart', (items) => {\r\n        // The items could be shown before they are decorated.\r\n        if (!isDecorated(items[0])) return;\r\n        // Emit the event.\r\n        items.forEach((item) => {\r\n          const eventController = getDecoration(item).eventController;\r\n          // The event is triggered also for items that have not\r\n          // changed their \"visibility\" state.\r\n          // This check is done to avoid useless re-rendering.\r\n          if (eventController.getPayload('show') !== true) {\r\n            eventController.emitEvent('show', true);\r\n          }\r\n        });\r\n      })\r\n      .on('hideEnd', (items) => {\r\n        // Emit the event.\r\n        items.forEach((item) => {\r\n          const eventController = getDecoration(item).eventController;\r\n          // The event is triggered also for items that have not\r\n          // changed their \"visibility\" state.\r\n          // This check is done to avoid useless re-rendering.\r\n          if (eventController.getPayload('show') !== false) {\r\n            eventController.emitEvent('show', false);\r\n          }\r\n        });\r\n      })\r\n\r\n      // Filter and sort events.\r\n      .on('filter', (shownItems, hiddenItems) => {\r\n        if (store.onFilter) store.onFilter(shownItems, hiddenItems);\r\n      })\r\n      .on('sort', (currentOrder, previousOrder) => {\r\n        if (store.onSort) store.onSort(currentOrder, previousOrder);\r\n      });\r\n\r\n    // Fix the dimensions of the items when they are dragged.\r\n    if (dragFixed) {\r\n      grid\r\n        .on('dragInit', (item) => {\r\n          // Let's set fixed widht/height to the dragged item\r\n          // so that it does not stretch unwillingly when\r\n          // it's appended to the document body for the\r\n          // duration of the drag.\r\n          const element = item.getElement();\r\n          // The element must exist.\r\n          invariant(element !== undefined);\r\n          // Get the computed dimensions.\r\n          const {width, height, paddingTop} = getComputedStyle(element);\r\n          // Save the previous style in case it was setted.\r\n          addDecoration(item, {\r\n            dragWidth: element.style.width,\r\n            dragHeight: element.style.height,\r\n            dragPaddingTop: element.style.paddingTop,\r\n          });\r\n          // Set the new style.\r\n          element.style.width = width;\r\n          element.style.height = height;\r\n          element.style.paddingTop = paddingTop;\r\n        })\r\n        .on('dragReleaseEnd', (item) => {\r\n          // Let's remove the fixed width/height from the\r\n          // dragged item now that it is back in a grid\r\n          // column and can freely adjust to it's\r\n          // surroundings.\r\n          const element = item.getElement();\r\n          // The element must exist.\r\n          invariant(element !== undefined);\r\n          // Get the old style.\r\n          const {dragWidth, dragHeight, dragPaddingTop} = getDecoration(item);\r\n          // Restore the previous style in case it was setted.\r\n          element.style.width = dragWidth;\r\n          element.style.height = dragHeight;\r\n          element.style.paddingTop = dragPaddingTop;\r\n        });\r\n    }\r\n\r\n    /* ---------------- */\r\n    /* ----- GRID ----- */\r\n    /* -----------------*/\r\n\r\n    // Check .\r\n    invariant(store.gridRef.current !== null);\r\n\r\n    // Work with the grid.\r\n    // @ts-ignore\r\n    grid._element = store.gridRef.current;\r\n    fillGridElement(store.gridRef.current, store.gridClass);\r\n    fillGrid(grid);\r\n\r\n    // \"onMount\" Callback.\r\n    if (onMount) onMount(grid);\r\n\r\n    // Delete the instance from the global map.\r\n    return () => {\r\n      // Destroy the controllers.\r\n      store.childrenController.destroy();\r\n      store.fiberController.destroy();\r\n      store.itemRemoveController.destroy();\r\n      store.itemAddController.destroy();\r\n      store.layoutController.destroy();\r\n    };\r\n  }, []); // eslint-disable-line\r\n\r\n  /* ---------------- */\r\n  /* ----- INIT ----- */\r\n  /* -----------------*/\r\n\r\n  // Init the controllers.\r\n  store.childrenController.useInit(children);\r\n  store.fiberController.useInit(store.gridRef);\r\n  store.itemRemoveController.useInit();\r\n  store.itemAddController.useInit();\r\n  store.layoutController.useInit();\r\n\r\n  // IsChanged flags.\r\n  const isFilterChanged = useReference([filter]);\r\n  const isSortChanged = useReference([sort, sortOptions]);\r\n\r\n  // Get items to add/remove.\r\n  useEffect(() => {\r\n    // Set drag enabled option.\r\n    addDecoration(grid, {dragEnabled});\r\n\r\n    // Set the items data.\r\n    vars.indicesToAdd = store.childrenController.getIndicesToAdd();\r\n    vars.addedDOMItems = store.fiberController.getStateNodes(vars.indicesToAdd);\r\n    vars.itemsToRemove = store.itemRemoveController.getItemsToRemove();\r\n    vars.itemsToRefresh = store.layoutController.getItemsToRefresh();\r\n    vars.itemsToShow = store.layoutController.getItemsToShow();\r\n    vars.itemsToHide = store.layoutController.getItemsToHide();\r\n\r\n    // This will remove lot of the implementation\r\n    // problems for the user.\r\n    store.onUnmount = onUnmount;\r\n    store.onDragStart = onDragStart;\r\n    store.onDragEnd = onDragEnd;\r\n    store.onFilter = onFilter;\r\n    store.onSort = onSort;\r\n    store.onSend = onSend;\r\n  });\r\n\r\n  /* ------------------- */\r\n  /* ----- ACTIONS ----- */\r\n  /* ------------------- */\r\n\r\n  useEffect(() => {\r\n    /* ---------------------- */\r\n    /* ---- ADD & REMOVE ---- */\r\n    /* ---------------------- */\r\n\r\n    // Remove items.\r\n    if (vars.itemsToRemove.length) {\r\n      removeItems(grid, vars.itemsToRemove);\r\n      // Set the flag.\r\n      vars.hasRemoved = true;\r\n    }\r\n\r\n    // Add items after the old ones are removed\r\n    // to add them in the right positions.\r\n    if (vars.indicesToAdd.length) {\r\n      addItems(grid, vars.addedDOMItems, vars.indicesToAdd, addOptions, filter);\r\n      // New Items.\r\n      const addedItems = grid.getItems(vars.indicesToAdd);\r\n      // Emit the new items to the itemComponents.\r\n      store.itemAddController.emit(addedItems);\r\n      // Set the flag.\r\n      vars.hasAdded = true;\r\n    }\r\n\r\n    /* ------------------------- */\r\n    /* ----- SORT & FILTER ----- */\r\n    /* ------------------------- */\r\n\r\n    // Filter items.\r\n    if (filter && (isFilterChanged || vars.hasAdded || forceSync)) {\r\n      filterItems(grid, filter);\r\n      // Set the flag.\r\n      vars.hasFiltered = true;\r\n    }\r\n\r\n    // Sort items.\r\n    if (sort && (isSortChanged || vars.hasAdded || forceSync)) {\r\n      sortItems(grid, sort, sortOptions);\r\n      // Set the flag.\r\n      vars.hasSorted = true;\r\n    }\r\n\r\n    /* ----------------------- */\r\n    /* ----- SHOW & HIDE ----- */\r\n    /* ----------------------- */\r\n\r\n    // Filter has priority on the items visibility.\r\n    if (!filter && vars.itemsToShow.length) {\r\n      showItems(grid, vars.itemsToShow);\r\n      // Set the flag.\r\n      vars.hasShown = true;\r\n    }\r\n\r\n    // Filter has priority on the items visibility.\r\n    if (!filter && vars.itemsToHide.length) {\r\n      hideItems(grid, vars.itemsToHide);\r\n      // Set the flag.\r\n      vars.hasHidden = true;\r\n    }\r\n\r\n    /* ------------------- */\r\n    /* ----- REFRESH ----- */\r\n    /* ------------------- */\r\n\r\n    // Items with dimensions to refresh.\r\n    if (vars.itemsToRefresh.length) {\r\n      grid.refreshItems(vars.itemsToRefresh);\r\n      // Set the flag.\r\n      vars.hasRefreshed = true;\r\n    }\r\n\r\n    /* ------------------ */\r\n    /* ----- LAYOUT ----- */\r\n    /* ------------------ */\r\n\r\n    // Layout is calculated only in the end.\r\n    // Check the previous flags.\r\n    if (\r\n      vars.hasAdded ||\r\n      vars.hasRemoved ||\r\n      vars.hasSorted ||\r\n      vars.hasFiltered ||\r\n      vars.hasRefreshed ||\r\n      vars.hasShown ||\r\n      vars.hasHidden\r\n    ) {\r\n      grid.layout(instantLayout);\r\n    }\r\n  });\r\n\r\n  /* ------------------ */\r\n  /* ----- RENDER ----- */\r\n  /* ------------------ */\r\n\r\n  // Provided value doesn't change the reference.\r\n  const value = useMemoized(() => ({\r\n    layoutController: store.layoutController,\r\n    grid,\r\n  }));\r\n\r\n  // render.\r\n  return (\r\n    <GridProvider value={value}>\r\n      <div\r\n        {...gridProps}\r\n        ref={store.gridRef}\r\n        {...store.fiberController.getFlagProp()}>\r\n        {/** The children controller handle some memoization */}\r\n        {store.childrenController.render((child, key) => (\r\n          <ItemComponent\r\n            key={key}\r\n            itemKey={key}\r\n            grid={grid}\r\n            propsToData={propsToData}\r\n            itemClasses={store.itemClasses}\r\n            itemAddController={store.itemAddController}\r\n            itemRemoveController={store.itemRemoveController}>\r\n            {child}\r\n          </ItemComponent>\r\n        ))}\r\n      </div>\r\n    </GridProvider>\r\n  );\r\n}\r\n\r\n// Proptypes.\r\nGridComponent.propTypes = {\r\n  grid: PropTypes.object.isRequired,\r\n  gridProps: PropTypes.object,\r\n  filter: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\r\n  sort: PropTypes.oneOfType([\r\n    PropTypes.string,\r\n    PropTypes.func,\r\n    PropTypes.arrayOf(PropTypes.string),\r\n  ]),\r\n  sortOptions: PropTypes.exact({\r\n    descending: PropTypes.bool,\r\n  }),\r\n  addOptions: PropTypes.exact({\r\n    show: PropTypes.bool,\r\n  }),\r\n  onSend: PropTypes.func,\r\n  onDragStart: PropTypes.func,\r\n  onDragEnd: PropTypes.func,\r\n  onFilter: PropTypes.func,\r\n  onSort: PropTypes.func,\r\n  onMount: PropTypes.func,\r\n  onUnmount: PropTypes.func,\r\n  forceSync: PropTypes.bool,\r\n  dragFixed: PropTypes.bool,\r\n  dragEnabled: PropTypes.bool,\r\n  instantLayout: PropTypes.bool,\r\n};\r\n\r\n// Default props.\r\nGridComponent.defaultProps = {\r\n  gridProps: {},\r\n  addOptions: {show: true},\r\n  sortOptions: {descending: false},\r\n  forceSync: false,\r\n  dragFixed: false,\r\n  dragEnabled: false,\r\n  instantLayout: false,\r\n};\r\n\r\n// Display name.\r\nGridComponent.displayName = 'GridComponent';\r\n", "/* React */\r\nimport React, {useEffect} from 'react';\r\nimport PropTypes from 'prop-types';\r\n/** Muuri */\r\nimport Muuri from 'muuri';\r\n/* Context */\r\nimport {ItemProvider} from '../contexts';\r\n/* Controllers */\r\nimport {EventController, ItemRefController} from '../controllers';\r\n/* Utils */\r\nimport {fillItem, fillItemElement} from '../utils/fillers';\r\nimport {useMemoized} from '../utils/hooks';\r\nimport {invariant} from '../invariant';\r\n/** Interfaces */\r\nimport type {ItemComponentProps} from '../interfaces';\r\n\r\n// Item component.\r\nexport function ItemComponent({\r\n  children: child,\r\n  itemClasses,\r\n  itemAddController,\r\n  itemRemoveController,\r\n  propsToData,\r\n  itemKey,\r\n  grid,\r\n}: ItemComponentProps) {\r\n  // The store provided doesn't change the reference.\r\n  const store = useMemoized(() => {\r\n    // Create the controllers.\r\n    const eventController = new EventController();\r\n    const itemRefController = new ItemRefController();\r\n    // Add the data that won't change.\r\n    itemRefController.set('key', itemKey);\r\n    itemRefController.set('eventController', eventController);\r\n    // Return the controllers.\r\n    return {eventController, itemRefController, itemRemoveController, grid};\r\n  });\r\n\r\n  // Set the props.\r\n  store.itemRefController.set('props', child.props);\r\n  store.itemRemoveController = itemRemoveController;\r\n  store.grid = grid;\r\n\r\n  // Set the data.\r\n  if (propsToData) {\r\n    // Get the data.\r\n    const data = propsToData(child.props);\r\n\r\n    // Must be an object.\r\n    invariant(\r\n      typeof data === 'object',\r\n      `The data returned by 'propsToData' must be an object, founded ${typeof data}`\r\n    );\r\n\r\n    // Set the data.\r\n    store.itemRefController.set('data', data);\r\n  }\r\n\r\n  // On mount.\r\n  useEffect(() => {\r\n    // Request the item.\r\n    itemAddController.requestItem((item) => {\r\n      fillItem(item);\r\n      // @ts-ignore\r\n      fillItemElement(item.getElement(), itemClasses);\r\n      store.itemRefController.setItem(item);\r\n    });\r\n\r\n    return () => {\r\n      // The item.\r\n      const item = store.itemRefController.getItem();\r\n      invariant(item !== null);\r\n\r\n      // The element.\r\n      const element = item.getElement();\r\n      invariant(element !== undefined);\r\n\r\n      // If the item is going to be unmounted\r\n      // and it is being dragged it have to end the event\r\n      // (Because it could be child of a different DOM element).\r\n      if (item.isDragging()) {\r\n        element.style.display = 'none';\r\n        element.style.visibility = 'hidden';\r\n\r\n        // @ts-ignore\r\n        if (item._drag) item._drag.destroy();\r\n        store.grid.getElement().appendChild(element);\r\n      }\r\n\r\n      // Remove the item.\r\n      store.itemRefController.delete();\r\n      store.itemRemoveController.removeItem(item);\r\n\r\n      // Destroy the controllers instances.\r\n      store.itemRefController.destroy();\r\n      store.eventController.destroy();\r\n    };\r\n  }, []); // eslint-disable-line\r\n\r\n  // Render.\r\n  return <ItemProvider value={store}>{child}</ItemProvider>;\r\n}\r\n\r\n// PropTypes.\r\nItemComponent.propTypes = {\r\n  itemAddController: PropTypes.object.isRequired,\r\n  itemClasses: PropTypes.arrayOf(PropTypes.string.isRequired).isRequired,\r\n  propsToData: PropTypes.func,\r\n  children: PropTypes.element.isRequired,\r\n  grid: PropTypes.instanceOf(Muuri).isRequired,\r\n};\r\n\r\n// Display name.\r\nItemComponent.displayName = 'ItemComponent';\r\n", "import {createContext, useContext} from 'react';\r\nimport type {DecoratedGrid} from '../interfaces';\r\nimport type {LayoutController} from '../controllers';\r\n\r\n// Context value shape.\r\nexport type GridContextValue = {\r\n  grid: DecoratedGrid;\r\n  layoutController: LayoutController;\r\n};\r\n\r\n// Grid context.\r\nexport const GridContext = createContext<Partial<GridContextValue>>({});\r\n// Grid provider.\r\nexport const GridProvider = GridContext.Provider;\r\n// Grid context hook.\r\nexport const useGridContext = () => useContext(GridContext);\r\n// Grid provider display name.\r\nGridContext.displayName = 'GridProvider';\r\n", "import {createContext, useContext} from 'react';\r\nimport type {ItemRefController, EventController} from '../controllers';\r\n\r\n// Context value shape.\r\nexport type ItemContextValue = {\r\n  itemRefController: ItemRefController;\r\n  eventController: EventController;\r\n};\r\n\r\n// Item context.\r\nexport const ItemContext = createContext<Partial<ItemContextValue>>({});\r\n// Item provider.\r\nexport const ItemProvider = ItemContext.Provider;\r\n// Item context hook.\r\nexport const useItemContext = () => useContext(ItemContext);\r\n// Item provider display name.\r\nItemContext.displayName = 'ItemProvider';\r\n", "/**\r\n * CONTROLLER: ITEM\r\n *\r\n * The purpose of this controller is to manage the\r\n * events trigger to the specific item the controller is assigned to.\r\n * This controllers is used by the hooks to re-render the components.\r\n */\r\nexport class EventController {\r\n  /** Map of <event, callback> */\r\n  _eventsMap = new Map<string, () => void>();\r\n  /** Map of <event, payload> */\r\n  _payloadsMap = new Map<string, any>();\r\n\r\n  /**\r\n   * Enable an event, it can be emitted.\r\n   *\r\n   * @param event - The event name.\r\n   * @param emitter - The callback.\r\n   */\r\n  enableEvent(event: string, emitter: () => void): void {\r\n    this._eventsMap.set(event, emitter);\r\n  }\r\n\r\n  /**\r\n   * Set an event payload and emit it the event.\r\n   *\r\n   * @param event - The event name.\r\n   * @param payload - The payload.\r\n   */\r\n  emitEvent(event: string, payload: any): void {\r\n    if (this.isEnabled(event)) {\r\n      this._payloadsMap.set(event, payload);\r\n      // @ts-ignore\r\n      this._eventsMap.get(event)();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the payload of the event.\r\n   *\r\n   * @param event - The event.\r\n   * @returns - The payload.\r\n   */\r\n  getPayload(event: string): any {\r\n    return this._payloadsMap.get(event);\r\n  }\r\n\r\n  /**\r\n   * Returns if at least an event is enabled.\r\n   *\r\n   * @param event - The event.\r\n   * @returns - If at least an event is enabled.\r\n   */\r\n  isEnabled(event: string): boolean {\r\n    return this._eventsMap.has(event);\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   */\r\n  destroy() {\r\n    this._eventsMap.clear();\r\n    this._payloadsMap.clear();\r\n  }\r\n}\r\n", "import type {DecoratedItem} from '../interfaces';\r\n\r\n/**\r\n * CONTROLLER: GRID -> ITEM\r\n *\r\n * The purpose of this controller is to pass to the\r\n * ItemComponents the items instances.\r\n * This can be done without knowing the added items and\r\n * relying only on the useEffect call order of the added items.\r\n */\r\nexport class ItemAddController {\r\n  /** The ItemComponents requests. */\r\n  _requests: ((item: DecoratedItem) => void)[] = [];\r\n\r\n  /**\r\n   * Clear the requests.\r\n   */\r\n  useInit(): void {\r\n    this._requests = [];\r\n  }\r\n\r\n  /**\r\n   * Emit the new items to the\r\n   * components that made a request.\r\n   *\r\n   * @param items - The items.\r\n   */\r\n  emit(items: DecoratedItem[]): void {\r\n    for (let i = 0; i < this._requests.length; i++) {\r\n      this._requests[i](items[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Request an item.\r\n   *\r\n   * @param cb - The callback.\r\n   */\r\n  requestItem(cb: (item: DecoratedItem) => void): void {\r\n    this._requests.push(cb);\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   */\r\n  destroy(): void {\r\n    this._requests = [];\r\n  }\r\n}\r\n", "const isProduction = process.env.NODE_ENV === 'production';\r\nconst prefix = 'Invariant failed';\r\n\r\n// Invarianto instance\r\nexport class Invariant extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n\r\n    this.name = 'Invariant';\r\n  }\r\n}\r\n\r\n// Throw an error if the condition fails\r\nexport function invariant(\r\n  condition: boolean,\r\n  message?: string\r\n): asserts condition {\r\n  if (condition) {\r\n    return;\r\n  }\r\n\r\n  if (isProduction) {\r\n    // In production we strip the message but still throw\r\n    throw new Invariant(prefix);\r\n  } else {\r\n    // When not in production we allow the message to pass through\r\n    // *This block will be removed in production builds*\r\n    throw new Invariant(`${prefix}: ${message || ''}`);\r\n  }\r\n}\r\n", "import {invariant} from '../invariant';\r\nimport {\r\n  addDecoration,\r\n  getDecoration,\r\n  removeDecorations,\r\n} from '../utils/decorators';\r\nimport type {DecoratedItem, ItemDecoration} from '../interfaces';\r\n\r\n/*\r\n * CONTROLLER: ITEM\r\n *\r\n * The purpose of this controller is to make possible\r\n * to set data in the item also if\r\n * it has not been created yet.\r\n */\r\nexport class ItemRefController {\r\n  /** The item. */\r\n  _item: DecoratedItem | null = null;\r\n  /** The temporary instance to hold the item's data. */\r\n  _instance: Partial<ItemDecoration> = {};\r\n\r\n  /**\r\n   * Set a decoration in the item.\r\n   *\r\n   * @param key - The decoration key.\r\n   * @param value - The decoration.\r\n   */\r\n  set<T extends keyof ItemDecoration>(key: T, value: ItemDecoration[T]): void {\r\n    if (this._item) {\r\n      addDecoration(this._item, {[key]: value});\r\n    } else {\r\n      this._instance[key] = value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a decoration value from the item.\r\n   *\r\n   * @param key - The decoration key.\r\n   * @returns - The decoration value.\r\n   */\r\n  get<T extends keyof ItemDecoration>(key: T): any {\r\n    if (this._item) {\r\n      return getDecoration(this._item)[key];\r\n    } else {\r\n      return this._instance[key];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all the decorations from the item.\r\n   */\r\n  delete(): void {\r\n    if (this._item) removeDecorations(this._item);\r\n  }\r\n\r\n  /**\r\n   * Set the item in the controller.\r\n   *\r\n   * @param item - The item.\r\n   */\r\n  setItem(item: DecoratedItem): void {\r\n    this._item = item;\r\n    addDecoration(this._item, this._instance);\r\n    this._instance = {};\r\n  }\r\n\r\n  /**\r\n   * Item getter.\r\n   *\r\n   * @returns - The item.\r\n   */\r\n  getItem(): DecoratedItem {\r\n    invariant(this._item !== null, 'The item has not been setted yet');\r\n    return this._item;\r\n  }\r\n\r\n  /**\r\n   * Returns if the item has been setted.\r\n   *\r\n   * @returns - If the item has been setted.\r\n   */\r\n  hasItem(): boolean {\r\n    return this._item !== null;\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   */\r\n  destroy(): void {\r\n    this._item = null;\r\n    this._instance = {};\r\n  }\r\n}\r\n", "import type {DecoratedItem} from '../interfaces';\r\n\r\n/**\r\n * CONTROLLER: GRID -> ITEM\r\n *\r\n * The purpose of this controller is to find the items to remove\r\n * based only on the unmount of the ItemComponents.\r\n */\r\nexport class ItemRemoveController {\r\n  /** The items to remove. */\r\n  _itemsToRemove: DecoratedItem[] = [];\r\n\r\n  /**\r\n   * Initialize.\r\n   */\r\n  useInit(): void {\r\n    this._itemsToRemove = [];\r\n  }\r\n\r\n  /**\r\n   * Request an item to be removed.\r\n   *\r\n   * @param item - The item to be removed.\r\n   */\r\n  removeItem(item: DecoratedItem): void {\r\n    this._itemsToRemove.push(item);\r\n  }\r\n\r\n  /**\r\n   * Return all the items to remove.\r\n   */\r\n  getItemsToRemove(): DecoratedItem[] {\r\n    return this._itemsToRemove;\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   */\r\n  destroy(): void {\r\n    this._itemsToRemove = [];\r\n  }\r\n}\r\n", "import {useEffect} from 'react';\r\nimport type {DecoratedItem} from '../interfaces';\r\n\r\n/**\r\n * CONTROLLER: GRID -> ITEMCONTEXT\r\n *\r\n * The purpose of this controller is to synchronize the calculation\r\n * of the layout following changes that have occurred within an item.\r\n * If the GridComponent is re-rendering allow to calculate a\r\n * single layout and greatly optimize the performance.\r\n */\r\nexport class LayoutController {\r\n  /** The items to refresh. */\r\n  _itemsToRefresh: DecoratedItem[];\r\n  /** The items to show. */\r\n  _itemsToShow: DecoratedItem[];\r\n  /** The items to hide. */\r\n  _itemsToHide: DecoratedItem[];\r\n  /** If the MuuriComponent parent is rendering. */\r\n  _isRendering: boolean;\r\n\r\n  /** Constructor. */\r\n  constructor() {\r\n    this._itemsToRefresh = [];\r\n    this._itemsToShow = [];\r\n    this._itemsToHide = [];\r\n    this._isRendering = false;\r\n  }\r\n\r\n  /**\r\n   * Init.\r\n   */\r\n  useInit(): void {\r\n    // Items.\r\n    this._itemsToRefresh = [];\r\n    this._itemsToShow = [];\r\n    this._itemsToHide = [];\r\n    // State.\r\n    this._isRendering = true;\r\n    // Change state.\r\n    // eslint-disable-next-line\r\n    useEffect(() => {\r\n      this._isRendering = false;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Refresh an item.\r\n   *\r\n   * @param item - The item to refresh.\r\n   */\r\n  refreshItem(item: DecoratedItem): void {\r\n    // If the component is rendering within the MuuriComponent.\r\n    if (this._isRendering) {\r\n      // The layout is managed by the MuuriComponent\r\n      // (Performance purpose).\r\n      this._itemsToRefresh.push(item);\r\n    } else {\r\n      // If the item is changing parent this\r\n      // will get the right parent.\r\n      const grid = item.getGrid();\r\n      // The layout is managed here.\r\n      grid.refreshItems([item]);\r\n      grid.layout();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set an item visibility.\r\n   *\r\n   * @param item - The item.\r\n   * @param visible - The visibility.\r\n   * @param instant - If the visibility change should happen without animations.\r\n   */\r\n  setItemVisibility(\r\n    item: DecoratedItem,\r\n    visible: boolean,\r\n    instant: boolean\r\n  ): void {\r\n    // If the component is rendering within the MuuriComponent.\r\n    if (this._isRendering) {\r\n      // The layout is managed by the MuuriComponent\r\n      // (Performance purpose).\r\n      if (visible) this._itemsToShow.push(item);\r\n      else this._itemsToHide.push(item);\r\n    } else {\r\n      // If the item is changing parent this\r\n      // will get the right parent.\r\n      const grid = item.getGrid();\r\n      // The layout is managed here.\r\n      if (visible) grid.show([item], {instant});\r\n      else grid.hide([item], {instant});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the items that have to be refreshed.\r\n   *\r\n   * @returns - The items.\r\n   */\r\n  getItemsToRefresh(): DecoratedItem[] {\r\n    return this._itemsToRefresh;\r\n  }\r\n\r\n  /**\r\n   * Get the items that have to be shown.\r\n   *\r\n   * @returns - The items.\r\n   */\r\n  getItemsToShow(): DecoratedItem[] {\r\n    return this._itemsToShow;\r\n  }\r\n\r\n  /**\r\n   * Get the items that have to be hidden.\r\n   *\r\n   * @returns - The items.\r\n   */\r\n  getItemsToHide(): DecoratedItem[] {\r\n    return this._itemsToHide;\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   */\r\n  destroy(): void {\r\n    this._itemsToRefresh = [];\r\n    this._itemsToShow = [];\r\n    this._itemsToHide = [];\r\n  }\r\n}\r\n", "import {useEffect} from 'react';\r\nimport type {RefObject, Key} from 'react';\r\nimport {invariant} from '../invariant';\r\nimport type {\r\n  Fiber,\r\n  Flag,\r\n  GridElementFiber,\r\n  ItemComponentFiber,\r\n} from '../interfaces';\r\n\r\n/**\r\n * CONTROLLER: GRID\r\n *\r\n * The purpose of this controller is to manage the fiber node of the GridElements.\r\n * The Fiber nodes allow to manage reparenting and easily access new added items elements.\r\n */\r\nexport class FiberController {\r\n  /** The fiber of the grid Element that contains all the ItemComponents. */\r\n  // @ts-ignore\r\n  _fiber: GridElementFiber;\r\n  /** The current flag value. */\r\n  _flag: Flag = '0';\r\n\r\n  /**\r\n   * Init the controller given the grid Element ref.\r\n   *\r\n   * @param gridElementRef - the ref of the grid element.\r\n   */\r\n  useInit(gridElementRef: RefObject<HTMLElement>): void {\r\n    this.updateFlag();\r\n    // eslint-disable-next-line\r\n    useEffect(() => {\r\n      invariant(gridElementRef.current !== null);\r\n      this._fiber = getFiber(gridElementRef.current);\r\n    }, []); // eslint-disable-line\r\n  }\r\n\r\n  /**\r\n   * Return the DOM elements in the chosen positions.\r\n   *\r\n   * @param orderedIndices - The positions.\r\n   * @returns - The elements.\r\n   */\r\n  getStateNodes(orderedIndices: number[]): HTMLElement[] {\r\n    const stateNodes: HTMLElement[] = [];\r\n    // If there aren't indices retun an empty array.\r\n    if (orderedIndices.length === 0) return stateNodes;\r\n\r\n    // The first child.\r\n    let child = getCurrentFiber(this._fiber, this._flag).child;\r\n\r\n    // Fill the state nodes array.\r\n    // We trust that the user input.\r\n    orderedIndices.forEach((index) => {\r\n      // @ts-ignore\r\n      while (child.index !== index) {\r\n        // @ts-ignore\r\n        child = child.sibling;\r\n      }\r\n\r\n      // @ts-ignore\r\n      stateNodes.push(getStateNode(child));\r\n    });\r\n\r\n    return stateNodes;\r\n  }\r\n\r\n  /**\r\n   * Append an itemComponent fiber\r\n   * (the same is done for the alternate if exists).\r\n   *\r\n   * @param child - The item.\r\n   */\r\n  append(itemComponentFiber: ItemComponentFiber): void {\r\n    // Get the current fiber.\r\n    const fiber = getCurrentFiber(this._fiber, this._flag);\r\n    // Append the fiber.\r\n    appendFiber(fiber, itemComponentFiber);\r\n\r\n    if (fiber.alternate) {\r\n      if (itemComponentFiber.alternate) {\r\n        // Append the alternate.\r\n        appendFiber(fiber.alternate, itemComponentFiber.alternate);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove an itemComponent fiber given the key of its Item\r\n   * (The same is done for the alternate if exists).\r\n   *\r\n   * @param key - The key of the item.\r\n   * @returns - The removed item.\r\n   */\r\n  remove(key: Key): ItemComponentFiber {\r\n    // Get the current fiber.\r\n    const fiber = getCurrentFiber(this._fiber, this._flag);\r\n    // Remove the fiber.\r\n    const removedChild = removeChild(fiber, key);\r\n\r\n    if (fiber.alternate) {\r\n      if (removedChild.alternate) {\r\n        // Remove the alternate.\r\n        removeChild(fiber.alternate, key);\r\n      }\r\n    }\r\n\r\n    return removedChild;\r\n  }\r\n\r\n  /**\r\n   * Return the props containing the flag value to add in the grid element.\r\n   *\r\n   * @returns - The props.\r\n   */\r\n  getFlagProp(): {[FlagProp]: Flag} {\r\n    return {[FlagProp]: this._flag};\r\n  }\r\n\r\n  /**\r\n   * Update the flag value.\r\n   */\r\n  updateFlag(): void {\r\n    if (this._flag === '0') this._flag = '1';\r\n    else this._flag = '0';\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   */\r\n  destroy(): void {\r\n    // @ts-ignore\r\n    this._fiber = null;\r\n  }\r\n}\r\n\r\n/**\r\n * The flag prop name.\r\n */\r\nexport const FlagProp = 'muuri-react-flag';\r\n\r\n/**\r\n * Get the fiber of the given grid element.\r\n *\r\n * @param grid - The element.\r\n * @return - The fiber node.\r\n */\r\nfunction getFiber(grid: HTMLElement): GridElementFiber {\r\n  const key = Object.keys(grid).find(\r\n    (key) =>\r\n      key.startsWith('__reactInternalInstance$') ||\r\n      key.startsWith('__reactFiber$')\r\n  );\r\n\r\n  invariant(\r\n    typeof key === 'string',\r\n    'Cannot find the __reactInternalInstance$'\r\n  );\r\n\r\n  // @ts-ignore\r\n  return grid[key];\r\n}\r\n\r\n/**\r\n * Return the current fiber.\r\n * Try to use the prop flag for the search first,\r\n * if this is not possible try the RootFiber.\r\n * The research on the flag is carried out because it is more\r\n * performing than the second and because if the React team\r\n * decides to change the functioning of the RootFiber,\r\n * not all features will stop working.\r\n * (It is rare for this to happen in the current version 16.x.x,\r\n * but if it does, it would not be a breacking change.)\r\n *\r\n * @param fiber - The fiber.\r\n * @param flag - the flag.\r\n * @returns - The current fiber.\r\n */\r\nfunction getCurrentFiber(\r\n  fiber: GridElementFiber,\r\n  currentFlag: Flag\r\n): GridElementFiber {\r\n  if (!fiber.alternate) return fiber;\r\n\r\n  // Flags.\r\n  const fiberFlag = fiber.memoizedProps[FlagProp];\r\n  const alternateFlag = fiber.alternate.memoizedProps[FlagProp];\r\n\r\n  // If the two flags are the same it should mean that\r\n  // in at least one of the items there has been a re-render\r\n  // from the last render of the GridComponent.\r\n  // We can no longer trust the flag prop and we have\r\n  // to look for the RootFiber and check which\r\n  // fiber is in the current tree.\r\n  if (fiberFlag === alternateFlag) {\r\n    let topFiber: Fiber = fiber;\r\n\r\n    // Get the top fiber\r\n    // (Not the RootFiber).\r\n    while (topFiber.return) {\r\n      topFiber = topFiber.return;\r\n    }\r\n\r\n    // Fibers.\r\n    const rootFiber = topFiber.stateNode;\r\n    const topCurrentFiber = rootFiber.current;\r\n\r\n    // The current fiber.\r\n    return topCurrentFiber === topFiber ? fiber : fiber.alternate;\r\n  }\r\n\r\n  // If we got here we can trust the flag prop to find the current Fiber.\r\n  return fiberFlag === currentFlag ? fiber : fiber.alternate;\r\n}\r\n\r\n/**\r\n * Returns the first stateNode among the descendants\r\n * of the given itemComponent Fiber.\r\n *\r\n * @param itemComponentFiber - The fiber.\r\n * @returns - The element.\r\n */\r\nfunction getStateNode(itemComponentFiber: ItemComponentFiber): HTMLElement {\r\n  // ItemComponent -> ItemProvider -> Item.\r\n  let itemFiber = itemComponentFiber.child.child;\r\n  // @ts-ignore\r\n  while (!(itemFiber.stateNode instanceof HTMLElement))\r\n    // @ts-ignore\r\n    itemFiber = itemFiber.child;\r\n\r\n  return itemFiber.stateNode;\r\n}\r\n\r\n/**\r\n * Append the child fiber in the last position among the children of the parent fiber.\r\n *\r\n * @param parent - The parent fiber.\r\n * @param child - The child fiber.\r\n */\r\nfunction appendFiber(\r\n  parent: GridElementFiber,\r\n  child: ItemComponentFiber\r\n): void {\r\n  if (!parent.child) {\r\n    // If it has no child.\r\n    parent.child = child;\r\n    child.index = 0;\r\n  } else {\r\n    let c = parent.child;\r\n    while (c.sibling) {\r\n      c = c.sibling;\r\n    }\r\n    child.index = c.index + 1;\r\n    // Inserted as last child.\r\n    c.sibling = child;\r\n  }\r\n\r\n  // Update the references.\r\n  child.return = parent;\r\n  // If we are in development.\r\n  if (child._debugOwner) child._debugOwner = parent.return?.return;\r\n}\r\n\r\n/**\r\n * Remove a child with the given key from the fiber.\r\n *\r\n * @param parent - The fiber.\r\n * @param key - The key of the item.\r\n * @return - The removed fiber.\r\n */\r\nfunction removeChild(parent: GridElementFiber, key: Key): ItemComponentFiber {\r\n  let child = parent.child;\r\n  let removedChild;\r\n\r\n  // @ts-ignore\r\n  if (hasNot(child, key)) {\r\n    // @ts-ignore\r\n    while (hasNot(child.sibling, key)) {\r\n      // @ts-ignore\r\n      child = child.sibling;\r\n    }\r\n    // @ts-ignore\r\n    removedChild = removeSibling(child);\r\n    // @ts-ignore\r\n    adjustIndices(child);\r\n  } else {\r\n    removedChild = removeFirstChild(parent);\r\n    // @ts-ignore\r\n    child = child.sibling;\r\n    if (child) adjustIndices(child);\r\n  }\r\n\r\n  removedChild.sibling = null;\r\n  return removedChild;\r\n}\r\n\r\n/**\r\n * Remove the first itemComponent fiber of a gridELement fiber and return it.\r\n *\r\n * @param GridElementFiber - The gridELement fiber.\r\n * @return - The removed itemComponent fiber.\r\n */\r\nfunction removeFirstChild(\r\n  gridElementFiber: GridElementFiber\r\n): ItemComponentFiber {\r\n  const removed = gridElementFiber.child;\r\n  // @ts-ignore\r\n  gridElementFiber.child = gridElementFiber.child.sibling;\r\n  // @ts-ignore\r\n  return removed;\r\n}\r\n\r\n/**\r\n * Remove the first sibling from a itemComponent fiber and return it.\r\n *\r\n * @param fiber - The fiber.\r\n * @return - The removed sibling.\r\n */\r\nfunction removeSibling(fiber: ItemComponentFiber): ItemComponentFiber {\r\n  const removed = fiber.sibling;\r\n  // @ts-ignore\r\n  fiber.sibling = fiber.sibling.sibling;\r\n  // @ts-ignore\r\n  return removed;\r\n}\r\n\r\n/**\r\n * Adjust the indices of the siblings of an itemComponent fiber.\r\n *\r\n * @param itemComponentFiber - The itemComponent fiber.\r\n */\r\nfunction adjustIndices(itemComponentFiber: ItemComponentFiber): void {\r\n  while (itemComponentFiber.sibling) {\r\n    itemComponentFiber.sibling.index = itemComponentFiber.index + 1;\r\n    itemComponentFiber = itemComponentFiber.sibling;\r\n  }\r\n}\r\n\r\n/**\r\n * Returns if the itemComponent fiber is not the parent of the item with the given key.\r\n *\r\n * @param itemComponentFiber - The itemComponent fiber.\r\n * @param key - The key of the item.\r\n * @return - If the itemComponent fiber is not the parent of the item with the given key.\r\n */\r\nfunction hasNot(itemComponentFiber: ItemComponentFiber, key: Key): boolean {\r\n  // ItemComponent -> ItemProvider -> Item.\r\n  return itemComponentFiber.child.child.key !== key;\r\n}\r\n", "import {Children} from 'react';\r\nimport type {ReactElement, Key} from 'react';\r\n\r\n/**\r\n * CONTROLLER: GRID\r\n *\r\n * The purpose of this controller is to manage children\r\n * during each render of the component, and provide\r\n * the indexes of the new children added.\r\n */\r\nexport class ChildrenController {\r\n  /** The old children. */\r\n  _oldChildrenArray: ReactElement[] = [];\r\n  /** The current children. */\r\n  _children: ReactElement[] = [];\r\n  /** The indices of the last added children. */\r\n  _indicesToAdd: number[] = [];\r\n  /** The number of the items being dragged. */\r\n  _dragCounter = 0;\r\n\r\n  /**\r\n   * Init all the settings given the new children.\r\n   *\r\n   * @param newChildren - the new children.\r\n   */\r\n  useInit(newChildren?: ReactElement[]): void {\r\n    // @ts-ignore\r\n    // We need to ensure that the children are in an array.\r\n    const newChildrenArray: ReactElement[] = Children.toArray(newChildren);\r\n\r\n    // The indices to add.\r\n    this._indicesToAdd = getIndicesToAdd(\r\n      newChildrenArray,\r\n      this._oldChildrenArray\r\n    );\r\n\r\n    // The _children will be used to map all\r\n    // the child in the render method.\r\n    // We can't use the ChildrenArray because we need the users\r\n    // key provided in the components and not the escaped one (e.g. .$1).\r\n    this._children = newChildren || [];\r\n    this._oldChildrenArray = newChildrenArray;\r\n  }\r\n\r\n  /**\r\n   * Remove a child in the given position and return it.\r\n   *\r\n   * @param index - The index of the child to remove.\r\n   * @returns - The removed child.\r\n   */\r\n  remove(index: number): ReactElement {\r\n    return this._oldChildrenArray.splice(index, 1)[0];\r\n  }\r\n\r\n  /**\r\n   * Append a child in the children array.\r\n   *\r\n   * @param child - The child to append.\r\n   */\r\n  append(child: ReactElement): void {\r\n    this._oldChildrenArray.push(child);\r\n  }\r\n\r\n  /**\r\n   * Returns the ordered array of indices of the added children.\r\n   */\r\n  getIndicesToAdd(): number[] {\r\n    return this._indicesToAdd;\r\n  }\r\n\r\n  /**\r\n   * Map all the children.\r\n   *\r\n   * @param cb - The callback.\r\n   * @returns - The mapped children.\r\n   */\r\n  render(cb: (child: ReactElement, key: Key) => ReactElement): ReactElement[] {\r\n    const children = Children.map(this._children, (child) => {\r\n      // @ts-ignore\r\n      // there are rare cases where the keys are not indispensable,\r\n      // the user may not choose to use at his own risk.\r\n      return cb(child, child.key);\r\n    });\r\n\r\n    // Flush the children.\r\n    this.flush();\r\n\r\n    return children;\r\n\r\n    /**\r\n    // If an item is being dragged we need to ensure\r\n    // that no child is inserted before it.\r\n    return this._dragCounter === 0\r\n      ? children\r\n      : getChildrenInSafePositions(children, this._indicesToAdd);\r\n       */\r\n  }\r\n\r\n  /**\r\n   * Increment the drag counter.\r\n   */\r\n  incrementDragCounter(): void {\r\n    this._dragCounter += 1;\r\n  }\r\n\r\n  /**\r\n   * Decrement the drag counter.\r\n   */\r\n  decrementDragCounter(): void {\r\n    this._dragCounter -= 1;\r\n  }\r\n\r\n  /**\r\n   * Remove the current children so they can be garbage collected.\r\n   */\r\n  flush(): void {\r\n    this._children = [];\r\n  }\r\n\r\n  /**\r\n   * Destroy the instance.\r\n   */\r\n  destroy(): void {\r\n    this.flush();\r\n  }\r\n}\r\n\r\n/**\r\n * Return an array of positions of the added children.\r\n * The algorithm is optimized for cases where the order of\r\n * the items does not change during re-renders (about 100% of cases).\r\n * The positions are in ascending order.\r\n *\r\n * @param newChildren - The new children.\r\n * @param oldChildren - The old children.\r\n * @return - The indices.\r\n */\r\nexport function getIndicesToAdd(\r\n  newChildren: React.ReactElement[],\r\n  oldChildren: React.ReactElement[]\r\n): number[] {\r\n  const indicesToAdd: number[] = [];\r\n  let oIndex = 0;\r\n\r\n  for (let nIndex = 0; nIndex < newChildren.length; nIndex++) {\r\n    // Finde the index.\r\n    const index = findIndex(oldChildren, newChildren[nIndex], oIndex);\r\n\r\n    if (index === -1) {\r\n      // If it is not present is a new Child.\r\n      indicesToAdd.push(nIndex);\r\n    } else {\r\n      // If it is present restart the research\r\n      // from the given index.\r\n      oIndex = index;\r\n    }\r\n  }\r\n\r\n  return indicesToAdd;\r\n}\r\n\r\n/**\r\n * Returns the index of the child in the children array,\r\n * if it is not present returns -1.\r\n * The research start from the given 'fromIndex'.\r\n *\r\n * @param child - The child to search.\r\n * @param children - The children.\r\n * @param fromIndex - The initial index.\r\n * @returns - The index of the child.\r\n */\r\nfunction findIndex(\r\n  children: React.ReactElement[],\r\n  child: React.ReactElement,\r\n  fromIndex: number\r\n): number {\r\n  fromIndex = fromIndex > children.length ? children.length : fromIndex;\r\n\r\n  // If the heuristics are respected the child will be here.\r\n  for (let index = fromIndex; index < children.length; index++) {\r\n    if (is(child, children[index])) return index;\r\n  }\r\n\r\n  // If the child is here the heuristics are not respected.\r\n  for (let index = 0; index < fromIndex; index++) {\r\n    if (is(child, children[index])) return index;\r\n  }\r\n\r\n  // The child is not present.\r\n  return -1;\r\n}\r\n\r\n/**\r\n * There would be the risk that a component will be inserted before\r\n * an item that is being dragged (and that is placed in a drag\r\n * container that is not the grid element). React would use\r\n * insertBefore to add the elements and this would cause an error.\r\n * To avoid this problem, if any item is being dragged,\r\n * all new components are added at the end so that\r\n * React uses appendChild to add the elements in the DOM.\r\n *\r\n * @param children - The new children to set.\r\n * @param indicesToAdd - The indices of the added children.\r\n * @returns - The children in safe postions.\r\n *\r\nfunction getChildrenInSafePositions(\r\n  newChildren: ReactElement[],\r\n  indicesToAdd: number[]\r\n): ReactElement[] {\r\n  // Check if there are dragged items.\r\n  if (indicesToAdd.length === 0) return newChildren;\r\n\r\n  const addedChildren: ReactElement[] = [];\r\n\r\n  // Set the added children.\r\n  indicesToAdd.reverse().forEach((index) => {\r\n    const [newChild] = newChildren.splice(index, 1);\r\n    addedChildren.push(newChild);\r\n  });\r\n\r\n  return newChildren.concat(addedChildren);\r\n}\r\n\r\n/**\r\n * Return if the components have the same key.\r\n *\r\n * @param componentA - The first component.\r\n * @param componentB - The second component.\r\n * @returns - If they have the same key.\r\n */\r\nfunction is(\r\n  componentA: React.ReactElement,\r\n  componentB: React.ReactElement\r\n): boolean {\r\n  return componentA.key === componentB.key;\r\n}\r\n", "import {addDecoration} from '../decorators';\r\nimport type {DecoratedGrid} from '../../interfaces';\r\n\r\n/**\r\n * Fill a grid instance:\r\n *  - Add the sizer element.\r\n *\r\n * @param grid - The Muuri instance.\r\n */\r\nexport function fillGrid(grid: DecoratedGrid): void {\r\n  const sizerElement = document.createElement('div');\r\n\r\n  // Keep the element hidden.\r\n  sizerElement.style.visibility = 'hidden';\r\n  sizerElement.style.position = 'absolute';\r\n  // Add the class.\r\n  sizerElement.classList.add('grid-sizer');\r\n\r\n  // Set the element.\r\n  addDecoration(grid, {sizerElement});\r\n  const gridElement = grid.getElement();\r\n\r\n  // Insert as first child.\r\n  if (gridElement.children.length === 0) {\r\n    gridElement.appendChild(sizerElement);\r\n  } else {\r\n    gridElement.insertBefore(sizerElement, gridElement.children[0]);\r\n  }\r\n}\r\n", "// Allowed position values.\r\nconst positions = ['relative', 'absolute', 'fixed'];\r\n\r\n/**\r\n * Fill a grid element:\r\n * - If it is not position the style.position is setted to \"relative\".\r\n * - The CSS \"containerClass\" is added.\r\n *\r\n * It also wrap the className setter to\r\n * avoid React to remove the standard class\r\n * of Muuri from the grid.\r\n *\r\n * @param gridElement - The element to fill.\r\n * @param gridClass - The Css class of the grid element.\r\n */\r\nexport function fillGridElement(\r\n  gridElement: HTMLElement,\r\n  gridClass: string\r\n): void {\r\n  const position = getComputedStyle(gridElement).position;\r\n\r\n  // Set the default position.\r\n  if (!positions.includes(position)) {\r\n    gridElement.style.position = positions[0];\r\n  }\r\n\r\n  // Set the grid class.\r\n  gridElement.classList.add(gridClass);\r\n\r\n  // Ensure that the grid class can't be removed.\r\n  const defaultSetAttribute = gridElement.setAttribute.bind(gridElement);\r\n  gridElement.setAttribute = function setAttribute(attribute, value) {\r\n    if (attribute === 'class') {\r\n      const classNames = (gridElement.getAttribute('class') || '').split(' ');\r\n      // Add the grid class.\r\n      if (!classNames.includes(gridClass)) value = `${value} ${gridClass}`;\r\n    }\r\n\r\n    defaultSetAttribute(attribute, value);\r\n  };\r\n}\r\n", "import type {DecoratedItem} from '../../interfaces';\r\nimport {addDecoration} from '../decorators';\r\n\r\n/**\r\n * Fill an item:\r\n * - Add the _component decoration.\r\n * - Re-define the _sortData property.\r\n *\r\n * @param item - The item to fill.\r\n */\r\nexport function fillItem(item: DecoratedItem): void {\r\n  addDecoration(item, {props: {}, data: {}});\r\n  // Change the sort data.\r\n  Object.defineProperty(item, '_sortData', {\r\n    get() {\r\n      return this.getData();\r\n    },\r\n    set() {\r\n      // nothing to do here.\r\n    },\r\n  });\r\n}\r\n", "/**\r\n * Fill an Item (outer) element:\r\n * - style.position setted to \"absolute\".\r\n *\r\n * It also wrap the className setter to\r\n * avoid React to remove the standard classes\r\n * of Muuri from the item.\r\n *\r\n * @param itemElement - The item element to fill.\r\n * @param itemClasses - The Css classes of the items.\r\n */\r\nexport function fillItemElement(\r\n  itemElement: HTMLElement,\r\n  itemClasses: string[]\r\n): void {\r\n  itemElement.style.position = 'absolute';\r\n\r\n  // Ensure that the Css item classes are not removed.\r\n  const defaultSetAttribute = itemElement.setAttribute.bind(itemElement);\r\n  itemElement.setAttribute = function setAttribute(attribute, value) {\r\n    if (attribute === 'class') {\r\n      const classNames = (itemElement.getAttribute('class') || '').split(' ');\r\n      const classNamesToAdd = classNames.filter((className) =>\r\n        itemClasses.includes(className)\r\n      );\r\n\r\n      // Add the Css items classes.\r\n      value = `${value} ${classNamesToAdd.join(' ')}`;\r\n    }\r\n\r\n    defaultSetAttribute(attribute, value);\r\n  };\r\n}\r\n", "import {useRef} from 'react';\r\n\r\n/**\r\n * Replacement for useCallback use case with empty array,\r\n * it memoize only the first function passed.\r\n * https://github.com/facebook/react/issues/15278.\r\n *\r\n * @param callback - The function to memoize.\r\n * @returns - The memoized function.\r\n */\r\nexport function useFunction<T extends (...args: any[]) => any>(callback: T): T {\r\n  return useRef<T>(callback).current;\r\n}\r\n", "import {useEffect, useRef} from 'react';\r\nimport {useReference} from './useReference';\r\n\r\n/**\r\n * Like useEffect but run instantly.\r\n *\r\n * @param didUpdate - The method to run.\r\n * @param deps - The dependecies.\r\n */\r\nexport function useInstantEffect(\r\n  didUpdate: () => void | (() => void),\r\n  deps: any[]\r\n): void {\r\n  // Deps check.\r\n  const needUpdate = useReference(deps);\r\n  const cleanUpRef = useRef<(() => void) | void>();\r\n\r\n  // Run.\r\n  if (needUpdate) {\r\n    if (cleanUpRef.current) cleanUpRef.current();\r\n    cleanUpRef.current = didUpdate();\r\n  }\r\n\r\n  // Catch unmount.\r\n  useEffect(() => {\r\n    return () => {\r\n      if (cleanUpRef.current) cleanUpRef.current();\r\n    };\r\n  }, []);\r\n}\r\n", "import {useRef} from 'react';\r\n\r\n/**\r\n * Accept a dependencyList and return if it has changed from\r\n * the previous render.\r\n *\r\n * @param dependencyList - The dependencyList.\r\n * @returns - If the dependencyList is changed from the previous render.\r\n */\r\nexport function useReference(dependencyList: any[]): boolean {\r\n  const ref = useRef<any[]>(dependencyList);\r\n\r\n  // If it is the first call return true.\r\n  if (ref.current === dependencyList) return true;\r\n\r\n  // Compare the dependencyLists.\r\n  const didUpdate = compare(ref.current, dependencyList);\r\n  // Keep the reference of the new one.\r\n  ref.current = dependencyList;\r\n\r\n  return didUpdate;\r\n}\r\n\r\n/**\r\n * Compare two dependencyLists and return if they are different.\r\n *\r\n * @param a - The first dependencyList to compare.\r\n * @param b - The second dependencyList to compare.\r\n * @returns - If the 2 dependencyLists are different.\r\n */\r\nfunction compare(a: any[], b: any[]): boolean {\r\n  if (a.length !== b.length) return true;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    if (a[i] !== b[i]) return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n", "import {useRef} from 'react';\r\n\r\n/**\r\n * Replacement for useMemo use case with empty array,\r\n * it memoize only the first computed value.\r\n * https://github.com/facebook/react/issues/15278.\r\n *\r\n * @param factory - The factory method.\r\n * @returns - The memoized value.\r\n */\r\nexport function useMemoized<T>(factory: () => T): T {\r\n  const valueRef = useRef<T>();\r\n\r\n  if (!valueRef.current) {\r\n    valueRef.current = factory();\r\n  }\r\n\r\n  return valueRef.current;\r\n}\r\n", "import {useState} from 'react';\r\nimport {useFunction} from './useFunction';\r\n\r\n/**\r\n * Returns a (memoized) function to re-render\r\n * the component in which the hook has been called.\r\n *\r\n * @returns - The re-render method.\r\n */\r\nexport function useRerender(): () => void {\r\n  const setState = useState<object>()[1];\r\n  return useFunction<() => void>(() => {\r\n    setState(Object.create(null));\r\n  });\r\n}\r\n", "import type {DecoratedGrid, ReactGridProps} from '../../interfaces';\r\n\r\n/**\r\n * Add the given items in the given positions.\r\n *\r\n * @param grid - The grid instance.\r\n * @param addedDOMItems - The added DOM items.\r\n * @param indicesToAdd - the positions in which to add the items.\r\n * @param addOptions - The add options.\r\n * @param filter - The filter.\r\n */\r\nexport function addItems(\r\n  grid: DecoratedGrid,\r\n  addedDOMItems: HTMLElement[],\r\n  indicesToAdd: number[],\r\n  addOptions: ReactGridProps['addOptions'],\r\n  filter: ReactGridProps['filter']\r\n): void {\r\n  for (let i = 0; i < addedDOMItems.length; i++) {\r\n    // Add the items.\r\n    grid.add(addedDOMItems[i], {index: indicesToAdd[i], layout: false});\r\n  }\r\n\r\n  // Show the added items (usefull just if the items are\r\n  // hidden by default and the filter is not setted).\r\n  if (!filter && addOptions?.show) {\r\n    grid.show(grid.getItems(indicesToAdd), {layout: false});\r\n  }\r\n}\r\n", "import type {DecoratedGrid, ReactGridProps} from '../../interfaces';\r\n\r\n/**\r\n * Filter the items with the given predicate.\r\n *\r\n * @param grid - The grid instance.\r\n * @param predicate - The filter predicate.\r\n */\r\nexport function filterItems(\r\n  grid: DecoratedGrid,\r\n  predicate: Exclude<ReactGridProps['filter'], undefined>\r\n): void {\r\n  grid.filter((item) => predicate(item.getData(), item), {layout: false});\r\n}\r\n", "import type {DecoratedGrid} from '../../interfaces';\r\n\r\n/** Class name. */\r\nconst gridClassName = 'containerClass';\r\n\r\n/**\r\n * Returns the Css class of the grid element.\r\n *\r\n * @param grid - The Muuri instance.\r\n * @returns - The class.\r\n */\r\nexport function getGridClass(grid: DecoratedGrid): string {\r\n  // @ts-ignore\r\n  return grid._settings[gridClassName];\r\n}\r\n", "import type {DecoratedGrid} from '../../interfaces';\r\n\r\n/** Class names. */\r\nconst itemClassNames = [\r\n  'itemClass',\r\n  'itemVisibleClass',\r\n  'itemHiddenClass',\r\n  'itemPositioningClass',\r\n  'itemDraggingClass',\r\n  'itemReleasingClass',\r\n  'itemPlaceholderClass',\r\n] as const;\r\n\r\n/**\r\n * Returns the items classes.\r\n *\r\n * @param grid - The Muuri instance.\r\n * @returns - The classes.\r\n */\r\nexport function getItemClasses(grid: DecoratedGrid): string[] {\r\n  // @ts-ignore\r\n  return itemClassNames.map((className) => grid._settings[className]);\r\n}\r\n", "import type {DecoratedGrid, DecoratedItem} from '../../interfaces';\r\n\r\n/**\r\n * Hide the given items.\r\n *\r\n * @param grid - The grid instance.\r\n * @param items - The items to hide.\r\n */\r\nexport function hideItems(grid: DecoratedGrid, items: DecoratedItem[]): void {\r\n  grid.hide(items, {layout: false});\r\n}\r\n", "import type {DecoratedGrid, DecoratedItem} from '../../interfaces';\r\n\r\n/**\r\n * Remove the given items.\r\n *\r\n * @param grid - The grid instance.\r\n * @param itemsToRemove - The items to remove.\r\n */\r\nexport function removeItems(\r\n  grid: DecoratedGrid,\r\n  itemsToRemove: DecoratedItem[]\r\n): void {\r\n  grid.remove(itemsToRemove, {layout: false, removeElements: false});\r\n}\r\n", "import type {DecoratedGrid, DecoratedItem} from '../../interfaces';\r\n\r\n/**\r\n * Show the given items.\r\n *\r\n * @param grid - The grid instance.\r\n * @param items - The items to show.\r\n */\r\nexport function showItems(grid: DecoratedGrid, items: DecoratedItem[]): void {\r\n  grid.show(items, {layout: false});\r\n}\r\n", "import type {\r\n  DecoratedGrid,\r\n  DecoratedItem,\r\n  ReactGridProps,\r\n} from '../../interfaces';\r\n\r\n/**\r\n * Sort the items.\r\n *\r\n * @param grid - The grid instance.\r\n * @param predicate - The sort predicate.\r\n * @param sortOptions - The sort options.\r\n */\r\nexport function sortItems(\r\n  grid: DecoratedGrid,\r\n  predicate: Exclude<ReactGridProps['sort'], undefined>,\r\n  sortOptions: ReactGridProps['sortOptions']\r\n): void {\r\n  // Disable the layout.\r\n  // @ts-ignore\r\n  sortOptions = {...(sortOptions || {}), layout: false};\r\n\r\n  // Handle a function.\r\n  if (typeof predicate === 'function') {\r\n    handleFunction(grid, predicate, sortOptions);\r\n  }\r\n\r\n  // Handle a string.\r\n  if (typeof predicate === 'string') {\r\n    handleString(grid, predicate, sortOptions);\r\n  }\r\n\r\n  // Hanndle an array of keys.\r\n  if (Array.isArray(predicate)) {\r\n    handleArray(grid, predicate, sortOptions);\r\n  }\r\n}\r\n\r\n/**\r\n * Sort the items given a predicate function.\r\n *\r\n * @param grid - The grid instance.\r\n * @param predicate - The predicate function.\r\n * @param sortOptions - The sort options.\r\n */\r\nfunction handleFunction(\r\n  grid: DecoratedGrid,\r\n  predicate: Extract<ReactGridProps['sort'], Function>,\r\n  sortOptions: ReactGridProps['sortOptions']\r\n): void {\r\n  grid.sort(\r\n    (itemA, itemB) => predicate(itemA.getData(), itemB.getData(), itemA, itemB),\r\n    sortOptions\r\n  );\r\n}\r\n\r\n/**\r\n * Sort the items given a predicate string.\r\n *\r\n * @param grid - The grid instance.\r\n * @param predicate - The predicate string.\r\n * @param sortOptions - The sort options.\r\n */\r\nfunction handleString(\r\n  grid: DecoratedGrid,\r\n  predicate: Extract<ReactGridProps['sort'], string>,\r\n  sortOptions: ReactGridProps['sortOptions']\r\n): void {\r\n  grid.sort(predicate, sortOptions);\r\n}\r\n\r\n/**\r\n * Sort the items given an array of keys.\r\n * If the key has a match, the item is inserted in that position, otherwise at the bottom.\r\n *\r\n * @param grid - The grid instance.\r\n * @param predicate - The array of keys.\r\n * @param sortOptions - The sort options.\r\n */\r\nfunction handleArray(\r\n  grid: DecoratedGrid,\r\n  predicate: Extract<ReactGridProps['sort'], Array<any>>,\r\n  sortOptions: ReactGridProps['sortOptions']\r\n): void {\r\n  const items: DecoratedItem[] = grid.getItems();\r\n  // Items that can be sorted.\r\n  const sortedItems: DecoratedItem[] = [];\r\n  // Items that can't be sorted.\r\n  const otherItems: DecoratedItem[] = [];\r\n\r\n  // Fills the arrays.\r\n  items.forEach((item) => {\r\n    const itemKey = item._component.key;\r\n    const index = predicate.findIndex((key) => key === itemKey);\r\n\r\n    if (index > -1) {\r\n      sortedItems[index] = item;\r\n    } else {\r\n      otherItems.push(item);\r\n    }\r\n  });\r\n\r\n  // Sort.\r\n  grid.sort(\r\n    Array.prototype.concat(\r\n      // Some position can be empty.\r\n      sortedItems.filter((item) => !!item),\r\n      otherItems\r\n    ),\r\n    sortOptions\r\n  );\r\n}\r\n", "/* React */\r\nimport React, {forwardRef, useEffect} from 'react';\r\nimport PropTypes from 'prop-types';\r\n/* Muuri */\r\nimport Muuri from 'muuri';\r\n/* Global map */\r\nimport {muuriMap} from '../muuri-map';\r\n/* Component */\r\nimport {GridComponent} from './gridComponent';\r\n/* Interfaces */\r\nimport type {DecoratedGrid, MuuriComponentProps} from '../interfaces';\r\n/* Utils */\r\nimport {useInstantEffect, useMemoized} from '../utils/hooks';\r\nimport {addDecoration, removeDecorations} from '../utils/decorators';\r\nimport {\r\n  getInstance,\r\n  handleRef,\r\n  setDragAutoScroll,\r\n  setDragContainer,\r\n  setDragSort,\r\n  setDragStartPredicate,\r\n} from '../utils/muuri';\r\n\r\n// Muuri component.\r\nexport const MuuriComponent = forwardRef<DecoratedGrid, MuuriComponentProps>(\r\n  function MuuriComponent(\r\n    {\r\n      /* GridComponent props. */\r\n      children,\r\n      id,\r\n      groupIds,\r\n      gridProps,\r\n      filter,\r\n      sort,\r\n      sortOptions,\r\n      addOptions,\r\n      propsToData,\r\n      onSend,\r\n      onDragStart,\r\n      onDragEnd,\r\n      onFilter,\r\n      onSort,\r\n      onMount,\r\n      onUnmount,\r\n      forceSync,\r\n      dragFixed,\r\n      dragEnabled,\r\n      instantLayout,\r\n      /* Muuri options. */\r\n      ...options\r\n    },\r\n    muuriRef\r\n  ) {\r\n    // Generate the Muuri instance.\r\n    const grid = useMemoized(() => {\r\n      // Remove the standard option '*'.\r\n      // @ts-ignore\r\n      options.items = [];\r\n      // Muuri (0.9.0) generate the \"ItemDrag\" instances only if\r\n      // drag is enabled. These instances do not handle scrolling well on touch devices,\r\n      // so we only create these instances if drag-and-drop have to be used\r\n      // (assuming that a boolean is passed to the prop instead of the default value \"null\").\r\n      // The enabling / disabling of the drag is managed in dragStartPredicate.\r\n      // @ts-ignore\r\n      options.dragEnabled = dragEnabled !== null;\r\n\r\n      // Allow the drag container to be a React.Ref<HTMLElement>.\r\n      setDragContainer(options);\r\n      // Allow the option to be an object ({ groupId }).\r\n      setDragSort(options, muuriMap);\r\n      // Allow the target elements to be React.Ref<HTMLElement>.\r\n      setDragAutoScroll(options);\r\n      // Allow enabling / disabling the drag-and-drop.\r\n      setDragStartPredicate(options);\r\n\r\n      // Generate the instance.\r\n      const grid = getInstance(options);\r\n\r\n      // Add the instance to the map.\r\n      if (id) muuriMap.set(grid, id);\r\n      // Add the decoration.\r\n      addDecoration(grid, {id});\r\n      // Set the ref.\r\n      handleRef(muuriRef, grid);\r\n\r\n      return grid;\r\n    }); // eslint-disable-line\r\n\r\n    // On unmount effect.\r\n    useEffect(() => {\r\n      // Clean-up.\r\n      return () => {\r\n        // Unset the ref.\r\n        handleRef(muuriRef, null);\r\n        // Remove the decorations.\r\n        removeDecorations(grid);\r\n        // Remove the instance from the map.\r\n        if (id) muuriMap.delete(id);\r\n        // Destroy the instace\r\n        grid.destroy();\r\n      };\r\n    }, []); // eslint-disable-line\r\n\r\n    // Allow the groupIds to be changed.\r\n    useInstantEffect(() => {\r\n      // decorate the instance\r\n      addDecoration(grid, {groupIds});\r\n      // Add the instance to the groups.\r\n      if (groupIds) {\r\n        groupIds.forEach((groupId) => {\r\n          muuriMap.setGroup(grid, groupId);\r\n        });\r\n      }\r\n\r\n      // Clean-up.\r\n      return () => {\r\n        // Remove the instance from the groups.\r\n        if (groupIds) {\r\n          groupIds.forEach((groupId) => {\r\n            muuriMap.deleteGroup(grid, groupId);\r\n          });\r\n        }\r\n      };\r\n    }, groupIds || []);\r\n\r\n    // Render.\r\n    return (\r\n      <GridComponent\r\n        grid={grid}\r\n        gridProps={gridProps}\r\n        filter={filter}\r\n        sort={sort}\r\n        sortOptions={sortOptions}\r\n        addOptions={addOptions}\r\n        propsToData={propsToData}\r\n        onSend={onSend}\r\n        onDragStart={onDragStart}\r\n        onDragEnd={onDragEnd}\r\n        onFilter={onFilter}\r\n        onSort={onSort}\r\n        onMount={onMount}\r\n        onUnmount={onUnmount}\r\n        forceSync={forceSync}\r\n        dragFixed={dragFixed}\r\n        dragEnabled={dragEnabled}\r\n        instantLayout={instantLayout}>\r\n        {children}\r\n      </GridComponent>\r\n    );\r\n  }\r\n);\r\n\r\n// Proptypes.\r\nMuuriComponent.propTypes = {\r\n  id: PropTypes.string,\r\n  groupIds: PropTypes.arrayOf(PropTypes.string.isRequired),\r\n  showDuration: PropTypes.number,\r\n  showEasing: PropTypes.string,\r\n  hideDuration: PropTypes.number,\r\n  hideEasing: PropTypes.string,\r\n  visibleStyles: PropTypes.shape({}),\r\n  hiddenStyles: PropTypes.shape({}),\r\n  // @ts-ignore\r\n  layout: PropTypes.oneOfType([\r\n    PropTypes.func,\r\n    PropTypes.exact({\r\n      fillGaps: PropTypes.bool,\r\n      horizontal: PropTypes.bool,\r\n      alignRight: PropTypes.bool,\r\n      alignBottom: PropTypes.bool,\r\n      rounding: PropTypes.bool,\r\n    }),\r\n  ]),\r\n  layoutOnResize: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\r\n  layoutDuration: PropTypes.number,\r\n  layoutEasing: PropTypes.string,\r\n  dragContainer: PropTypes.oneOfType([\r\n    PropTypes.instanceOf(HTMLElement),\r\n    PropTypes.shape({\r\n      current: PropTypes.instanceOf(HTMLElement).isRequired,\r\n    }),\r\n  ]),\r\n  // @ts-ignore\r\n  dragStartPredicate: PropTypes.oneOfType([\r\n    PropTypes.func,\r\n    PropTypes.exact({\r\n      distance: PropTypes.number,\r\n      delay: PropTypes.number,\r\n      handle: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\r\n    }),\r\n  ]),\r\n  dragAxis: PropTypes.oneOf(['x', 'y', 'xy'] as const),\r\n  dragSort: PropTypes.oneOfType([\r\n    PropTypes.bool,\r\n    PropTypes.func,\r\n    PropTypes.exact({\r\n      groupId: PropTypes.string.isRequired,\r\n    }),\r\n  ]),\r\n  // @ts-ignore\r\n  dragSortHeuristics: PropTypes.exact({\r\n    sortInterval: PropTypes.number,\r\n    minDragDistance: PropTypes.number,\r\n    minBounceBackAngle: PropTypes.number,\r\n  }),\r\n  // @ts-ignore\r\n  dragSortPredicate: PropTypes.oneOfType([\r\n    PropTypes.func,\r\n    PropTypes.exact({\r\n      action: PropTypes.oneOf(['move', 'swap'] as const),\r\n      migrateAction: PropTypes.oneOf(['move', 'swap'] as const),\r\n      threshold: PropTypes.number,\r\n    }),\r\n  ]),\r\n  // @ts-ignore\r\n  dragRelease: PropTypes.exact({\r\n    duration: PropTypes.number,\r\n    easing: PropTypes.string,\r\n    useDragContainer: PropTypes.bool,\r\n  }),\r\n  // @ts-ignore\r\n  dragCssProps: PropTypes.exact({\r\n    touchAction: PropTypes.string,\r\n    userSelect: PropTypes.string,\r\n    userDrag: PropTypes.string,\r\n    tapHighlightColor: PropTypes.string,\r\n    touchCallout: PropTypes.string,\r\n    contentZooming: PropTypes.string,\r\n  }),\r\n  // @ts-ignore\r\n  dragPlaceholder: PropTypes.exact({\r\n    enabled: PropTypes.bool,\r\n    createElement: PropTypes.func,\r\n    onCreate: PropTypes.func,\r\n    onRemove: PropTypes.func,\r\n    easing: PropTypes.string,\r\n    duration: PropTypes.number,\r\n  }),\r\n  containerClass: PropTypes.string,\r\n  itemClass: PropTypes.string,\r\n  itemVisibleClass: PropTypes.string,\r\n  itemHiddenClass: PropTypes.string,\r\n  itemPositioningClass: PropTypes.string,\r\n  itemDraggingClass: PropTypes.string,\r\n  itemReleasingClass: PropTypes.string,\r\n  itemPlaceholderClass: PropTypes.string,\r\n};\r\n\r\n// Default props.\r\nMuuriComponent.defaultProps = {\r\n  ...Muuri.defaultOptions,\r\n  dragEnabled: null,\r\n};\r\n\r\n// Display name.\r\nMuuriComponent.displayName = 'MuuriComponent';\r\n", "import type {DecoratedGrid} from './interfaces';\r\n\r\n/**\r\n * Map that links the Muuri instances to\r\n * their id and group ids.\r\n */\r\nexport class MuuriMap {\r\n  /** Map of <id, Muuri instance>. */\r\n  _idMap = new Map<string, DecoratedGrid>();\r\n  /** Map of <id, Muuri instances>. */\r\n  _groupMap = new Map<string, DecoratedGrid[]>();\r\n\r\n  /**\r\n   * Get the grid instance with the chosen id.\r\n   *\r\n   * @param id - The id.\r\n   * @returns - The grid instance.\r\n   */\r\n  get(id: string): DecoratedGrid | null {\r\n    return this._idMap.get(id) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all the grid instances in the group of the given id.\r\n   * The reference of the group array never changes.\r\n   *\r\n   * @param groupId - The group id.\r\n   * @returns - The array of grid instances.\r\n   */\r\n  getGroup(groupId: string): DecoratedGrid[] {\r\n    const group = this._groupMap.get(groupId);\r\n\r\n    if (!group) {\r\n      const newGroup: DecoratedGrid[] = [];\r\n      this._groupMap.set(groupId, newGroup);\r\n      return newGroup;\r\n    } else {\r\n      return group;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all the grid instances in the map.\r\n   *\r\n   * @returns - The grid instances.\r\n   */\r\n  getAll(): DecoratedGrid[] {\r\n    return Array.from(this._idMap.values());\r\n  }\r\n\r\n  /**\r\n   * Set the grid instance with the given id.\r\n   *\r\n   * @param grid - The grid instance.\r\n   * @param id - The id of the instance.\r\n   * @returns - The muuriMap.\r\n   */\r\n  set(grid: DecoratedGrid, id: string): this {\r\n    this._idMap.set(id, grid);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Set the grid instance in the group of the given id.\r\n   *\r\n   * @param grid - The grid instance.\r\n   * @param groupId - The id of the group.\r\n   * @returns - The muuriMap.\r\n   */\r\n  setGroup(grid: DecoratedGrid, groupId: string): this {\r\n    const group = this._groupMap.get(groupId);\r\n\r\n    if (group) {\r\n      group.push(grid);\r\n    } else {\r\n      this._groupMap.set(groupId, [grid]);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Delete the grid instance with the given id.\r\n   *\r\n   * @param id - The id of the instance.\r\n   * @returns - The muuriMap.\r\n   */\r\n  delete(id: string): this {\r\n    this._idMap.delete(id);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Delete the instance from the group with the given id.\r\n   *\r\n   * @param grid - The grid instance.\r\n   * @param groupIds - The group ids of the instance.\r\n   */\r\n  deleteGroup(grid: DecoratedGrid, groupId: string): this {\r\n    const group = this._groupMap.get(groupId);\r\n\r\n    if (group) {\r\n      const index = group.indexOf(grid);\r\n      if (index > -1) group.splice(index, 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clear the maps.\r\n   */\r\n  clear(): this {\r\n    this._idMap.clear();\r\n    this._groupMap.clear();\r\n    return this;\r\n  }\r\n}\r\n\r\nexport const muuriMap: MuuriMap = new MuuriMap();\r\n", "import Muuri from 'muuri';\r\nimport type {DecoratedGrid} from '../../interfaces';\r\n\r\n/**\r\n * Generate and returns a muuri instance with the given options.\r\n *\r\n * @param options - The options.\r\n * @returns - The muuri instance.\r\n */\r\nexport function getInstance(options: object): DecoratedGrid {\r\n  const el = document.createElement('div');\r\n  // The element won't be visible.\r\n  el.style.display = 'none';\r\n  // Muuri (0.8.0) need an element in the DOM to be instanciated.\r\n  document.body.appendChild(el);\r\n\r\n  // Generate the instance.\r\n  const grid = new Muuri(el, options);\r\n\r\n  // Remove the element.\r\n  document.body.removeChild(el);\r\n\r\n  return grid;\r\n}\r\n", "/**\r\n * Set the value in the ref.\r\n *\r\n * @param ref - The ref.\r\n * @param value - The value\r\n */\r\nexport function handleRef<T>(ref: React.Ref<T>, value: T | null): void {\r\n  if (!ref) return;\r\n\r\n  if (typeof ref === 'function') ref(value);\r\n  // @ts-ignore\r\n  else if ('current' in ref) ref.current = value;\r\n}\r\n", "import {invariant} from '../../invariant';\r\nimport type {\r\n  GridProps,\r\n  DragAutoScrollTarget,\r\n  DragAutoScrollTargetElement,\r\n} from '../../interfaces';\r\n\r\n/**\r\n * Wrap the 'dragAutoScroll' option.\r\n * Allow the target element to be a ref.\r\n *\r\n * @param options - The grid options.\r\n */\r\nexport function setDragAutoScroll(options: GridProps): void {\r\n  const {dragAutoScroll} = options;\r\n\r\n  // Wrap the options only if it is setted.\r\n  if (!dragAutoScroll || !Array.isArray(dragAutoScroll.targets)) return;\r\n\r\n  dragAutoScroll.targets.forEach((target) => {\r\n    // Check if it is an object to wrap.\r\n    if (isTargetElement(target)) return;\r\n\r\n    invariant(\r\n      'element' in target,\r\n      'You must provide an element in each scroll target'\r\n    );\r\n\r\n    // Scroll target element.\r\n    const element = target.element;\r\n    // The element ref.\r\n    let ref: {current: DragAutoScrollTargetElement | null} = {\r\n      current: null,\r\n    };\r\n\r\n    // Define the element property.\r\n    Object.defineProperty(target, 'element', {\r\n      get() {\r\n        return ref.current;\r\n      },\r\n      set(element) {\r\n        if (isTargetElement(element)) {\r\n          ref.current = element;\r\n        } else {\r\n          ref = element;\r\n        }\r\n      },\r\n    });\r\n\r\n    // Set the element.\r\n    target.element = element;\r\n  });\r\n}\r\n\r\n/**\r\n * Returns if the target is a valid element.\r\n *\r\n * @param element - The target.\r\n * @returns - If the target is a valid element.\r\n */\r\nexport function isTargetElement(target: DragAutoScrollTarget): boolean {\r\n  return (\r\n    // A DOM element.\r\n    target instanceof HTMLElement ||\r\n    // The window.\r\n    target instanceof window.constructor\r\n  );\r\n}\r\n", "import type {GridProps} from '../../interfaces';\r\n\r\n/**\r\n * Wrap the 'dragContainer' option.\r\n * Allow it to be a ref.\r\n *\r\n * @param options - The grid options.\r\n */\r\nexport function setDragContainer(options: GridProps): void {\r\n  const {dragContainer} = options;\r\n  // The drag container ref.\r\n  let ref = {current: null};\r\n\r\n  // Define the property.\r\n  Object.defineProperty(options, 'dragContainer', {\r\n    get() {\r\n      return ref.current;\r\n    },\r\n    set(value) {\r\n      if (!value || value instanceof Element) {\r\n        ref.current = value;\r\n      } else {\r\n        ref = value;\r\n      }\r\n    },\r\n  });\r\n\r\n  // Set the drag container.\r\n  options.dragContainer = dragContainer;\r\n}\r\n", "import {invariant} from '../../invariant';\r\nimport type {GridProps} from '../../interfaces';\r\nimport type {MuuriMap} from '../../muuri-map';\r\n\r\n/**\r\n * Wrap the 'dragSort' option.\r\n * Allow it to be an object containing the groupId of the chosen MuuriComponents.\r\n *\r\n * @param options - The grid options.\r\n * @param globalMap - The globalMap.\r\n */\r\nexport function setDragSort(options: GridProps, globalMap: MuuriMap): void {\r\n  const {dragSort} = options;\r\n  // Parse this options only if it is an object.\r\n  if (!dragSort || typeof dragSort !== 'object') return;\r\n  // Check the options.\r\n  invariant(\r\n    typeof dragSort.groupId === 'string',\r\n    'You must provide a string as groupId'\r\n  );\r\n\r\n  // The group, its reference doesn't change.\r\n  const group = globalMap.getGroup(dragSort.groupId);\r\n\r\n  // dragSort method.\r\n  options.dragSort = () => group;\r\n}\r\n", "import Muuri from 'muuri';\r\nimport {getDecoration, isDecorated} from '../decorators';\r\nimport type {GridProps, DecoratedDragStartPredicate} from '../../interfaces';\r\n\r\n/**\r\n * Wrap the 'dragStartPredicate' option.\r\n * To allow the drag:\r\n * - The global drag must be enabled.\r\n * - The item must be draggable.\r\n *\r\n * @param options - The grid options.\r\n */\r\nexport function setDragStartPredicate(options: GridProps): void {\r\n  const {dragStartPredicate} = options;\r\n\r\n  // Default predicate.\r\n  const defaultStartPredicate = getDefaultStartPredicate(dragStartPredicate);\r\n\r\n  // Wrap the method.\r\n  options.dragStartPredicate = (item, event) => {\r\n    if (!getDecoration(item.getGrid()).dragEnabled) return false;\r\n    if (isDecorated(item) && getDecoration(item).draggable === false)\r\n      return false;\r\n\r\n    return defaultStartPredicate(item, event);\r\n  };\r\n}\r\n\r\n/**\r\n * Given the dragStartPredicate option return the default method.\r\n *\r\n * @param dragStartPredicate - The dragStartPredicate option.\r\n * @returns - The defaultStartPredicate method.\r\n */\r\nfunction getDefaultStartPredicate(\r\n  dragStartPredicate: GridProps['dragStartPredicate']\r\n): DecoratedDragStartPredicate {\r\n  return typeof dragStartPredicate === 'function'\r\n    ? dragStartPredicate\r\n    : (item, event) => {\r\n        return Muuri.ItemDrag.defaultStartPredicate(\r\n          item,\r\n          event,\r\n          dragStartPredicate\r\n        );\r\n      };\r\n}\r\n", "export * from './useData';\r\nexport * from './useDrag';\r\nexport * from './useDraggable';\r\nexport * from './useGrid';\r\nexport * from './useRefresh';\r\nexport * from './useShow';\r\nexport * from './useVisibility';\r\n", "import {useItemContext} from '../contexts';\r\nimport {invariant} from '../invariant';\r\nimport {useFunction} from '../utils/hooks';\r\n\r\n// The method return by the hook.\r\nexport type SetDataMethod = (data: object, options?: UseDataOptions) => void;\r\n\r\n// The options of the hook and the method.\r\nexport type UseDataOptions = {\r\n  /** If the data have to be merged with the old one. */\r\n  merge?: boolean;\r\n};\r\n\r\n/**\r\n * The useData hook allow to set the data to the item in which the hook has been called.\r\n * It also returns the setter method.\r\n *\r\n * @param initialData - The data.\r\n * @param options - The options.\r\n * @returns - The setter method.\r\n */\r\nexport function useData(\r\n  initialData?: object,\r\n  options?: UseDataOptions\r\n): SetDataMethod {\r\n  const {itemRefController} = useItemContext();\r\n\r\n  // Check if the hook is called inside an item.\r\n  invariant(\r\n    itemRefController !== undefined,\r\n    'The useData hook can be used only inside an Item'\r\n  );\r\n\r\n  // Because of memoization, The identity of the function is guaranteed\r\n  // to be stable so it will be safe to omit them as a dependency.\r\n  const setData = useFunction<SetDataMethod>((data, options) => {\r\n    // Check if the data is an object.\r\n    invariant(\r\n      typeof data === 'object',\r\n      `The data must be an object, founded: ${typeof data}`\r\n    );\r\n\r\n    // Default options.\r\n    options = options || useData.defaultOptions;\r\n    // Set the data.\r\n    if (options.merge) {\r\n      // Merge.\r\n      const currentData = itemRefController.get('data') || {};\r\n      itemRefController.set('data', Object.assign(currentData, data));\r\n    } else {\r\n      // Set.\r\n      itemRefController.set('data', data);\r\n    }\r\n  });\r\n\r\n  // Set the inital data.\r\n  if (typeof initialData === 'object') {\r\n    setData(initialData, options);\r\n  }\r\n\r\n  return setData;\r\n}\r\n\r\n// Default options.\r\nuseData.defaultOptions = {merge: false};\r\n", "import {useEffect} from 'react';\r\nimport {useItemContext} from '../contexts';\r\nimport {invariant} from '../invariant';\r\nimport {useRerender} from '../utils/hooks';\r\n\r\n/**\r\n * The useDrag hook re-render item (in which the hook has been called)\r\n * Every time it is dragged/released.\r\n * The hook returns if the item is being dragged.\r\n *\r\n * @returns - If the item is being dragged.\r\n */\r\nexport function useDrag(): boolean {\r\n  const {eventController} = useItemContext();\r\n  const reRender = useRerender();\r\n\r\n  // Check if the hook is called inside an item.\r\n  invariant(\r\n    eventController !== undefined,\r\n    'The useDrag hook can be used only inside an Item'\r\n  );\r\n\r\n  // Enable the event.\r\n  useEffect(() => {\r\n    eventController.enableEvent('drag', reRender);\r\n  }, [eventController, reRender]);\r\n\r\n  return eventController.getPayload('drag') || false;\r\n}\r\n", "import {useItemContext} from '../contexts';\r\nimport {invariant} from '../invariant';\r\nimport {useFunction} from '../utils/hooks';\r\n\r\n// The method returned by the hook.\r\nexport type SetDraggableMethod = (draggable: boolean) => void;\r\n\r\n/**\r\n * The useDraggable hook allow to decide if the item (in which the hook has been called)\r\n * can be dragged or not.\r\n * It returns the setter method.\r\n *\r\n * @returns - The setter method.\r\n */\r\nexport function useDraggable(): SetDraggableMethod {\r\n  const {itemRefController} = useItemContext();\r\n\r\n  // Check if the hook is called inside an item.\r\n  invariant(\r\n    itemRefController !== undefined,\r\n    'The useDraggable hook can be used only inside an Item'\r\n  );\r\n\r\n  const setDraggable = useFunction<SetDraggableMethod>((draggable) => {\r\n    // Set if the item can be dragged.\r\n    itemRefController.set('draggable', !!draggable);\r\n  });\r\n\r\n  return setDraggable;\r\n}\r\n", "import {useEffect} from 'react';\r\nimport {useGridContext, useItemContext} from '../contexts';\r\nimport {invariant} from '../invariant';\r\nimport {useRerender} from '../utils/hooks';\r\nimport type {DecoratedGrid} from '../interfaces';\r\n\r\n// The data returned by the hook.\r\nexport type GridData = {\r\n  id?: string;\r\n  groupIds?: string[];\r\n  grid: DecoratedGrid;\r\n};\r\n\r\n/**\r\n * The useGrid hook return the data of the MuuriComponent parent of the\r\n * item (in which the hook has been called).\r\n *\r\n * @returns - The data of the MuuriComponent.\r\n */\r\nexport function useGrid(): GridData {\r\n  const {eventController} = useItemContext();\r\n  const gridContext = useGridContext();\r\n  const reRender = useRerender();\r\n\r\n  // Check if the hook is called inside an item.\r\n  invariant(\r\n    eventController !== undefined && gridContext.grid !== undefined,\r\n    'The useGrid hook can be used only inside an Item'\r\n  );\r\n\r\n  // The context is not updated when the hook is trigger\r\n  // so we need to get the updated instance from the eventController.\r\n  const grid = eventController.getPayload('send') || gridContext.grid;\r\n\r\n  // Enable the event.\r\n  useEffect(() => {\r\n    eventController.enableEvent('send', reRender);\r\n  }, [eventController, reRender]);\r\n\r\n  return {\r\n    id: grid._component.id,\r\n    groupIds: grid._component.groupIds,\r\n    grid,\r\n  };\r\n}\r\n", "import {useEffect, useCallback} from 'react';\r\nimport {useGridContext, useItemContext} from '../contexts';\r\nimport {invariant} from '../invariant';\r\n\r\n// The method returned by the hook.\r\nexport type RefreshMethod = () => void;\r\n\r\n/**\r\n * The useRefresh hook allow to notify the MuuriComponent that the\r\n * item dimensions are changed, so that it can update the layout.\r\n *\r\n * @param deps - The dependencies.\r\n * @returns - The refresh method.\r\n */\r\nexport function useRefresh(deps: any[] = []): RefreshMethod {\r\n  const {layoutController} = useGridContext();\r\n  const {itemRefController} = useItemContext();\r\n\r\n  // Check if the hook is called inside an item.\r\n  invariant(\r\n    itemRefController !== undefined && layoutController !== undefined,\r\n    'The useRefresh hook can be used only inside an Item'\r\n  );\r\n\r\n  // Because of memoization, The identity of the function is guaranteed\r\n  // to be stable so it will be safe to omit it as a dependency.\r\n  const refresh = useCallback(() => {\r\n    if (!itemRefController.hasItem()) return;\r\n    // Get the item.\r\n    const item = itemRefController.getItem();\r\n    // If the component is rendering within the MuuriComponent.\r\n    layoutController.refreshItem(item);\r\n  }, [layoutController, itemRefController]);\r\n\r\n  useEffect(() => {\r\n    refresh();\r\n  }, deps.concat(refresh)); // eslint-disable-line\r\n\r\n  return refresh;\r\n}\r\n", "import {useEffect} from 'react';\r\nimport {useItemContext} from '../contexts';\r\nimport {invariant} from '../invariant';\r\nimport {useRerender} from '../utils/hooks';\r\n\r\n/**\r\n * The useShow hook allow you to know if the item is showing.\r\n * The item will re-render each time its visibility change.\r\n *\r\n * @returns - If the item is showing.\r\n */\r\nexport function useShow(): boolean | undefined {\r\n  const {eventController} = useItemContext();\r\n  const reRender = useRerender();\r\n\r\n  // Check if the hook is called inside an item.\r\n  invariant(\r\n    eventController !== undefined,\r\n    'The useShow hook can be used only inside an Item'\r\n  );\r\n\r\n  // Enable the event.\r\n  useEffect(() => {\r\n    eventController.enableEvent('show', reRender);\r\n  }, [eventController, reRender]);\r\n\r\n  return eventController.getPayload('show');\r\n}\r\n", "import {useItemContext, useGridContext} from '../contexts';\r\nimport {invariant} from '../invariant';\r\nimport {useFunction} from '../utils/hooks';\r\n\r\n// The method returned by the hook.\r\nexport type SetVisibilityMethod = (\r\n  visible: boolean,\r\n  options?: UseVisibilityOptions\r\n) => void;\r\n\r\n// The options of the hook.\r\nexport type UseVisibilityOptions = {\r\n  /** If the animation should be skipped. */\r\n  instant?: boolean;\r\n};\r\n\r\n/**\r\n * The useVisibility hook allow you to show/hide the item in which the hook has been called.\r\n *\r\n * @returns - The setter method.\r\n */\r\nexport function useVisibility(): SetVisibilityMethod {\r\n  const {layoutController} = useGridContext();\r\n  const {eventController, itemRefController} = useItemContext();\r\n\r\n  // Check if the hook is called inside an item.\r\n  invariant(\r\n    itemRefController !== undefined &&\r\n      layoutController !== undefined &&\r\n      eventController !== undefined,\r\n    'The useVisibility hook can be used only inside an Item'\r\n  );\r\n\r\n  // Set visibility.\r\n  const setVisibility = useFunction<SetVisibilityMethod>((visible, options) => {\r\n    if (!itemRefController.hasItem()) return;\r\n    if (!!visible === eventController.getPayload('show')) return;\r\n\r\n    // Default options.\r\n    options = options || useVisibility.defaultOptions;\r\n\r\n    // Set the visibility.\r\n    layoutController.setItemVisibility(\r\n      itemRefController.getItem(),\r\n      visible,\r\n      options.instant === true\r\n    );\r\n  });\r\n\r\n  return setVisibility;\r\n}\r\n\r\n// Default options.\r\nuseVisibility.defaultOptions = {instant: false};\r\n", "import {invariant} from '../invariant';\r\n\r\n/** Responsive style options. */\r\nexport interface ResponsiveStyleOptions {\r\n  /** Columns value from 0 to 1. */\r\n  columns: number;\r\n  /** Margin. */\r\n  margin?: string | number;\r\n  /** Width / height ratio. */\r\n  ratio?: number;\r\n  /** Height. */\r\n  height?: string | number;\r\n}\r\n\r\n/**\r\n * Get the responsive style.\r\n *\r\n * @param options - The options.\r\n * @returns - The style.\r\n */\r\nexport function getResponsiveStyle(options: ResponsiveStyleOptions) {\r\n  // Check options.\r\n  invariant(typeof options === 'object', 'You must define options');\r\n\r\n  // Check columns.\r\n  invariant(\r\n    typeof options.columns === 'number' &&\r\n      options.columns > 0 &&\r\n      options.columns <= 1,\r\n    'options.columns must be a number between 0 (excluded) and 1 (included)'\r\n  );\r\n\r\n  // Check height and ratio.\r\n  invariant(\r\n    typeof options.ratio === 'number' ||\r\n      typeof options.height === 'number' ||\r\n      typeof options.height === 'string',\r\n    'You must provide at least one option between height and ratio'\r\n  );\r\n\r\n  // Check that the height and the ratio options are not setted togheter.\r\n  invariant(\r\n    typeof options.ratio !== 'number' ||\r\n      (typeof options.height !== 'number' &&\r\n        typeof options.height !== 'string'),\r\n    'You cannot provide both the height and the ratio options'\r\n  );\r\n\r\n  // The margin values.\r\n  const {margin, mStatic, mDynamic} = getResponsiveMargin(\r\n    options.margin || '0px'\r\n  );\r\n  // The item width.\r\n  const {needCalc, width} = getResponsiveWidth(\r\n    options.columns,\r\n    mStatic,\r\n    mDynamic\r\n  );\r\n\r\n  // If ratio is used set The paddingTop\r\n  // instad of the heght, the child element must\r\n  // have \"display: absolute\".\r\n  return options.ratio\r\n    ? {\r\n        width: needCalc ? `calc(${width})` : width,\r\n        paddingTop: getResponsivePaddingTop(width, options.ratio, needCalc),\r\n        height: `0px`,\r\n        borderWidth: '0px',\r\n        margin,\r\n      }\r\n    : {\r\n        width: needCalc ? `calc(${width})` : width,\r\n        paddingTop: `0px`,\r\n        // @ts-ignore\r\n        height: getFixedHeight(options.height),\r\n        borderWidth: '0px',\r\n        margin,\r\n      };\r\n}\r\n\r\n/**\r\n * Get the responsive width.\r\n *\r\n * @param columns - The percentage.\r\n * @param mStatic - The static margin.\r\n * @param mDynamic - The dynamic margin.\r\n * @returns - The width.\r\n */\r\nfunction getResponsiveWidth(\r\n  columns: number,\r\n  mStatic: number,\r\n  mDynamic: number\r\n) {\r\n  const needCalc = mStatic !== 0;\r\n  const rawWidth = columns * 100 - mDynamic;\r\n  const width = needCalc ? `${rawWidth}% - ${mStatic}px` : `${rawWidth}%`;\r\n\r\n  return {needCalc, width};\r\n}\r\n\r\n/**\r\n * Get the responsive paddingTop.\r\n *\r\n * @param width - The width.\r\n * @param ratio - The width/height ratio.\r\n * @param needCalc - If the width need to be surrounded by calc().\r\n * @returns - The paddingTop.\r\n */\r\nfunction getResponsivePaddingTop(\r\n  width: string,\r\n  ratio: number,\r\n  needCalc: boolean\r\n): string {\r\n  return needCalc\r\n    ? `calc((${width}) / ${ratio})`\r\n    : `${parseFloat(width) / ratio}%`;\r\n}\r\n\r\n/**\r\n * Get the fixed height.\r\n *\r\n * @param height - The mixed height.\r\n * @returns - The height string.\r\n */\r\nfunction getFixedHeight(height: string | number): string {\r\n  return typeof height === 'number' ? `${height}px` : height;\r\n}\r\n\r\n/**\r\n * The responsive margin.\r\n *\r\n * @param margin - The margin.\r\n * @returns - The responsive margin.\r\n */\r\nfunction getResponsiveMargin(margin: string | number) {\r\n  if (typeof margin === 'number') margin = `${margin}px`;\r\n  const margins = margin.trim().split(' ');\r\n\r\n  // Margin default values.\r\n  let leftMargin = '0px';\r\n  let rightMargin = '0px';\r\n  let mDynamic = 0;\r\n  let mStatic = 0;\r\n\r\n  // Get the values from the input.\r\n  if (margins.length === 1) {\r\n    leftMargin = rightMargin = margins[0];\r\n  } else if (margins.length === 2) {\r\n    leftMargin = rightMargin = margins[1];\r\n  } else if (margins.length === 3) {\r\n    leftMargin = rightMargin = margins[1];\r\n  } else if (margins.length === 4) {\r\n    leftMargin = margins[3];\r\n    rightMargin = margins[1];\r\n  }\r\n\r\n  // Set dynamic/static margins.\r\n  if (leftMargin.indexOf('%') === -1) mStatic += parseFloat(leftMargin);\r\n  else mDynamic += parseFloat(leftMargin);\r\n  if (rightMargin.indexOf('%') === -1) mStatic += parseFloat(rightMargin);\r\n  else mDynamic += parseFloat(rightMargin);\r\n\r\n  return {\r\n    margin,\r\n    mStatic,\r\n    mDynamic,\r\n  };\r\n}\r\n", "import {invariant} from '../invariant';\r\nimport {getResponsiveStyle} from './getResponsiveStyle';\r\nimport type {DecoratedGrid} from '../interfaces';\r\nimport type {ResponsiveStyleOptions} from './getResponsiveStyle';\r\n\r\n/** Static style options. */\r\nexport interface StaticStyleOptions extends ResponsiveStyleOptions {\r\n  /** Container width, can be a number or a string (e.g. \"100px\"). */\r\n  grid: DecoratedGrid;\r\n}\r\n\r\n/**\r\n * Get the static style.\r\n *\r\n * @param options - The options.\r\n * @returns - The style.\r\n */\r\nexport function getStaticStyle(options: StaticStyleOptions) {\r\n  const style = getResponsiveStyle(options);\r\n\r\n  // Check the options.\r\n  invariant(\r\n    'grid' in options,\r\n    'You mast pass the grid instance to get the static style.'\r\n  );\r\n\r\n  // The sizer element.\r\n  const sizerElement = options.grid.getSizerElement();\r\n\r\n  // Set the style in the sizer.\r\n  Object.assign(sizerElement.style, style);\r\n\r\n  // Get the style from the sizer.\r\n  const {width, height, paddingTop, margin} = window.getComputedStyle(\r\n    sizerElement\r\n  );\r\n\r\n  return {width, height, paddingTop, margin};\r\n}\r\n", "import React from 'react';\r\nimport type {ComponentType} from 'react';\r\nimport * as hooks from '../hooks';\r\nimport {invariant} from '../invariant';\r\n\r\n// Hook names.\r\nconst hooksNames = [\r\n  'useData',\r\n  'useDrag',\r\n  'useDraggable',\r\n  'useGrid',\r\n  'useRefresh',\r\n  'useShow',\r\n  'useVisibility',\r\n] as const;\r\n\r\n// Handler type.\r\ntype HookHandlerType = [\r\n  typeof hooksNames[number],\r\n  <T>(t: T) => {[x: string]: T}\r\n];\r\n\r\n// Hook handlers.\r\nconst HooksHandlers: HookHandlerType[] = [\r\n  ['useData', /*       */ getHandler('setData')],\r\n  ['useDrag', /*       */ getHandler('isDragging')],\r\n  ['useDraggable', /*  */ getHandler('setDraggable')],\r\n  ['useGrid', /*       */ getHandler('gridData')],\r\n  ['useRefresh', /*    */ getHandler('refresh')],\r\n  ['useShow', /*       */ getHandler('isShowing')],\r\n  ['useVisibility', /* */ getHandler('setVisibility')],\r\n];\r\n\r\n/**\r\n * Return the handler with the given key.\r\n *\r\n * @param key - The key.\r\n * @returns - The method.\r\n */\r\nexport function getHandler(key: string): <T>(t: T) => {[x: string]: T} {\r\n  return function handler<T>(payload: T) {\r\n    return {[key]: payload};\r\n  };\r\n}\r\n\r\n/**\r\n * Run all the handlers and merge all the payloads.\r\n *\r\n * @param hooksHandlers - The handlers.\r\n * @returns - The merged payload.\r\n */\r\nfunction getMerged(hooksHandlers: HookHandlerType[]): object {\r\n  return Object.assign(\r\n    {},\r\n    ...hooksHandlers.map(([hookName, handler]) => {\r\n      const payload = hooks[hookName]();\r\n      return handler(payload);\r\n    })\r\n  );\r\n}\r\n\r\n/**\r\n * Item HOC for hooks.\r\n *\r\n * @param Component - The component to wrap.\r\n * @param enabledHooks - The hooks to enable.\r\n * @returns - The wrapped component.\r\n */\r\nexport function withHooks<T extends object>(\r\n  Component: ComponentType<T>,\r\n  enabledHooks: typeof hooksNames[number][]\r\n) {\r\n  // There must be an array of hooks to enable.\r\n  invariant(\r\n    Array.isArray(enabledHooks),\r\n    'An array of hooks name must be provided to wrap an item.'\r\n  );\r\n\r\n  // All the hooks must be valid.\r\n  enabledHooks.forEach((hookName) => {\r\n    invariant(hooksNames.includes(hookName), `Invalid item hook: ${hookName}`);\r\n  });\r\n\r\n  // There must be at least one hook to enable.\r\n  invariant(\r\n    enabledHooks.length !== 0,\r\n    'To wrap an item at least one hook must be provided.'\r\n  );\r\n\r\n  // Get the handlers array of the enabled hook.\r\n  const hooksHandlers = HooksHandlers.filter(([hookName]) =>\r\n    enabledHooks.includes(hookName)\r\n  );\r\n\r\n  // Return the HOC.\r\n  return function WrappedItem(props: T) {\r\n    // The hooks will run in the 'getMerged' method.\r\n    return <Component {...(props as T)} {...getMerged(hooksHandlers)} />;\r\n  };\r\n}\r\n"],
  "mappings": "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",
  "names": ["require_ReactPropTypesSecret", "__commonJSMin", "exports", "module", "ReactPropTypesSecret", "require_factoryWithThrowingShims", "__commonJSMin", "exports", "module", "ReactPropTypesSecret", "emptyFunction", "emptyFunctionWithReset", "shim", "props", "propName", "componentName", "location", "propFullName", "secret", "err", "getShim", "ReactPropTypes", "require_prop_types", "__commonJSMin", "exports", "module", "ReactIs", "throwOnDirectAccess", "src_exports", "__export", "AutoScroller", "ChildrenController", "EventController", "FiberController", "FlagProp", "GridComponent", "GridContext", "GridProvider", "ItemAddController", "ItemComponent", "ItemContext", "ItemDrag", "ItemProvider", "ItemRefController", "ItemRemoveController", "LayoutController", "MuuriComponent", "MuuriMap", "getHandler", "getIndicesToAdd", "getResponsiveStyle", "getStaticStyle", "muuriMap", "useData", "useDrag", "useDraggable", "useGrid", "useGridContext", "useItemContext", "useRefresh", "useShow", "useVisibility", "withHooks", "import_muuri", "import_muuri", "decorationKey_default", "isDecorated", "instance", "decorationKey_default", "addDecoration", "instance", "decoration", "isDecorated", "decorationKey_default", "__spreadValues", "getDecoration", "instance", "decorationKey_default", "removeDecorations", "decorated", "Muuri", "getDecoration", "data", "import_react", "import_prop_types", "import_react", "import_prop_types", "import_muuri", "import_react", "GridContext", "GridProvider", "useGridContext", "import_react", "ItemContext", "ItemProvider", "useItemContext", "EventController", "event", "emitter", "payload", "ItemAddController", "items", "i", "cb", "prefix", "Invariant", "message", "invariant", "condition", "ItemRefController", "key", "value", "addDecoration", "getDecoration", "removeDecorations", "item", "invariant", "ItemRemoveController", "item", "import_react", "LayoutController", "item", "grid", "visible", "instant", "import_react", "FiberController", "gridElementRef", "invariant", "getFiber", "orderedIndices", "stateNodes", "child", "getCurrentFiber", "index", "getStateNode", "itemComponentFiber", "fiber", "appendFiber", "key", "removedChild", "removeChild", "FlagProp", "grid", "currentFlag", "fiberFlag", "alternateFlag", "topFiber", "itemFiber", "parent", "_a", "c", "hasNot", "removeSibling", "adjustIndices", "removeFirstChild", "gridElementFiber", "removed", "import_react", "ChildrenController", "newChildren", "newChildrenArray", "getIndicesToAdd", "index", "child", "cb", "children", "oldChildren", "indicesToAdd", "oIndex", "nIndex", "findIndex", "fromIndex", "is", "componentA", "componentB", "fillGrid", "grid", "sizerElement", "addDecoration", "gridElement", "positions", "fillGridElement", "gridElement", "gridClass", "position", "defaultSetAttribute", "attribute", "value", "fillItem", "item", "addDecoration", "fillItemElement", "itemElement", "itemClasses", "defaultSetAttribute", "attribute", "value", "classNamesToAdd", "className", "import_react", "useFunction", "callback", "import_react", "import_react", "useReference", "dependencyList", "ref", "didUpdate", "compare", "a", "b", "i", "useInstantEffect", "didUpdate", "deps", "needUpdate", "useReference", "cleanUpRef", "import_react", "useMemoized", "factory", "valueRef", "import_react", "useRerender", "setState", "useFunction", "ItemComponent", "child", "itemClasses", "itemAddController", "itemRemoveController", "propsToData", "itemKey", "grid", "store", "useMemoized", "eventController", "EventController", "itemRefController", "ItemRefController", "data", "invariant", "item", "fillItem", "fillItemElement", "element", "React", "ItemProvider", "PropTypes", "Muuri", "addItems", "grid", "addedDOMItems", "indicesToAdd", "addOptions", "filter", "i", "filterItems", "grid", "predicate", "item", "gridClassName", "getGridClass", "grid", "itemClassNames", "getItemClasses", "grid", "className", "hideItems", "grid", "items", "removeItems", "grid", "itemsToRemove", "showItems", "grid", "items", "sortItems", "grid", "predicate", "sortOptions", "__spreadProps", "__spreadValues", "handleFunction", "handleString", "handleArray", "itemA", "itemB", "items", "sortedItems", "otherItems", "item", "itemKey", "index", "key", "GridComponent", "children", "gridProps", "grid", "filter", "sort", "sortOptions", "addOptions", "propsToData", "onSend", "onDragStart", "onDragEnd", "onFilter", "onSort", "onMount", "onUnmount", "forceSync", "dragFixed", "dragEnabled", "instantLayout", "store", "useMemoized", "getGridClass", "getItemClasses", "ChildrenController", "FiberController", "ItemAddController", "ItemRemoveController", "LayoutController", "vars", "item", "fromGrid", "fromIndex", "getDecoration", "sentPayload", "addDecoration", "toGrid", "toIndex", "toChildrenController", "toFiberController", "invariant", "fromChildrenController", "fromFiberController", "itemFiber", "itemComponent", "event", "receivedPayload", "items", "isDecorated", "eventController", "shownItems", "hiddenItems", "currentOrder", "previousOrder", "element", "width", "height", "paddingTop", "dragWidth", "dragHeight", "dragPaddingTop", "fillGridElement", "fillGrid", "isFilterChanged", "useReference", "isSortChanged", "removeItems", "addItems", "addedItems", "filterItems", "sortItems", "showItems", "hideItems", "value", "React", "GridProvider", "__spreadValues", "__spreadProps", "child", "key", "ItemComponent", "PropTypes", "import_react", "import_prop_types", "import_muuri", "MuuriMap", "id", "groupId", "group", "newGroup", "grid", "index", "muuriMap", "import_muuri", "getInstance", "options", "el", "grid", "Muuri", "handleRef", "ref", "value", "setDragAutoScroll", "options", "dragAutoScroll", "target", "isTargetElement", "invariant", "element", "ref", "setDragContainer", "options", "dragContainer", "ref", "value", "setDragSort", "options", "globalMap", "dragSort", "invariant", "group", "import_muuri", "setDragStartPredicate", "options", "dragStartPredicate", "defaultStartPredicate", "getDefaultStartPredicate", "item", "event", "getDecoration", "isDecorated", "Muuri", "MuuriComponent", "_a", "muuriRef", "_b", "children", "id", "groupIds", "gridProps", "filter", "sort", "sortOptions", "addOptions", "propsToData", "onSend", "onDragStart", "onDragEnd", "onFilter", "onSort", "onMount", "onUnmount", "forceSync", "dragFixed", "dragEnabled", "instantLayout", "options", "__objRest", "grid", "useMemoized", "setDragContainer", "setDragSort", "muuriMap", "setDragAutoScroll", "setDragStartPredicate", "getInstance", "addDecoration", "handleRef", "removeDecorations", "useInstantEffect", "groupId", "React", "GridComponent", "PropTypes", "__spreadProps", "__spreadValues", "Muuri", "hooks_exports", "__export", "useData", "useDrag", "useDraggable", "useGrid", "useRefresh", "useShow", "useVisibility", "useData", "initialData", "options", "itemRefController", "useItemContext", "invariant", "setData", "useFunction", "data", "currentData", "import_react", "useDrag", "eventController", "useItemContext", "reRender", "useRerender", "invariant", "useDraggable", "itemRefController", "useItemContext", "invariant", "useFunction", "draggable", "import_react", "useGrid", "eventController", "useItemContext", "gridContext", "useGridContext", "reRender", "useRerender", "invariant", "grid", "import_react", "useRefresh", "deps", "layoutController", "useGridContext", "itemRefController", "useItemContext", "invariant", "refresh", "item", "import_react", "useShow", "eventController", "useItemContext", "reRender", "useRerender", "invariant", "useVisibility", "layoutController", "useGridContext", "eventController", "itemRefController", "useItemContext", "invariant", "useFunction", "visible", "options", "getResponsiveStyle", "options", "invariant", "margin", "mStatic", "mDynamic", "getResponsiveMargin", "needCalc", "width", "getResponsiveWidth", "getResponsivePaddingTop", "getFixedHeight", "columns", "rawWidth", "ratio", "height", "margins", "leftMargin", "rightMargin", "getStaticStyle", "options", "style", "getResponsiveStyle", "invariant", "sizerElement", "width", "height", "paddingTop", "margin", "import_react", "hooksNames", "HooksHandlers", "getHandler", "key", "payload", "getMerged", "hooksHandlers", "hookName", "handler", "hooks_exports", "withHooks", "Component", "enabledHooks", "invariant", "props", "React", "__spreadValues", "AutoScroller", "Muuri", "ItemDrag"]
}
